///*
// * z99.c
// *
// *  Created on: 27 груд. 2019 р.
// *      Author: KozakVF
// */
//
//
//             //    Головной файл для устройства защиты электродвигателя //TkA_N16
//        //исключено запоминание /ПУСК/  NumSamples=248;
//#include  <msp430x13x.h>                // Standard Equations
//#include  <math.h>
//
//#define Serial     0    // Серийный номер изделия от 0 до 65535
//#define Modif      20   // Номер модификации изделия в завсимости от алгоритма, типов датчиков и др.
//                        // от 0 до 255 (рекомендуется от 20)
//#define EnableNasos     // Комментирование этой директивы выключает программный блок управления насосом//
//#define EnableConvert   // Комментирование этой директивы позволяет выводить на индикатор битовые значения всех токов
////#define EnableRS232   // Комментирование этой директивы запрещает обмен по интерфейсу
//
////#define TK              // Комментирование этой директивы позволяет перейти от ТК к ТК112-1
////#define DiffZasch     // Комментирование этой директивы запрещает работу дифзащиты
//#define Dt_nov          // Комментирование этой директивы позволяет перейти с Rvx=1,2 0m на Rvx=3,9 Om
//
////#define ZaschTV     // Комментирование этой директивы запрещает работу защиты по температуре и влажности
////#define Kras           // Комментир этой дир позвол перейти от задержек в мин к зад в сек
////#define OBPH           // Комментирование этой директивы позволяет запретить ограничение
//                        //времени работы насоса(OBPH)
////#define TKM           // Комментирование этой директивы позволяет перейти от ТКM к ТК
////#define TK112M        // Комментирование этой директивы позволяет перейти от платы ТК112М к       //
////#define Ppusk           // Комментирование этой директивы позволяет перейти от Ppusk к ТК
//#define GerKTZ        // Комментирование этой директивы позволяет запретить сброс KTZ
//                        // от кнопки СТОП
//#define Period    200   // Длительность одного цикла, ms  /200
//#define TauLevel  2     // Постоянная времени для датчиков уровня, s
//#define TauIzol   3
//#define Parol     3     // Пароль для ввода уставки без перемычки пароля
//
//   //Количество байт(вместе с CRC)принимаемых Подчиненным по функциям в запросе МБ
//#define ColByt_F105     4 // Для фунции 105
//#define ColByt_F106     4 // Для фунции 106
//#define ColByt_F110     9 // Для фунции 110
//   // Постоянная времени для защиты по сопротивлению изоляции, s.
//#define TauIcx    1     // Постоянная времени для защиты по току сухого хода
//#define TauIasim  10     // Постоянная времени для защиты по току ассиметрии //7 10
//
//#define  TauIndI   1//4     // Постояная времени вывода на индикатор показаний тока
//#define  DiffZerro2 2000  //23,200,242
//#define TimeStartMax     20  //Время блокировки команды "Start"
//#define TimePuskStopMax  20//0//10 //Время пуска или останов двигателя 50*200(Period)=10000 ms=10s  20
//#define TimeIsol         2 //10 // Время задержки определения защиты изоляции(с прогрм. закороткой входа и выхода  фильтра изол.) после выключения-выключения ЭД или после сброса (включения) устройства
//                              // Причём !!!ДОЛЖНО!!! (TimePuskStopMax>TimeIsol); (TimePuskStopMax-TimeIsol) определяет гарантированное время расчёта изоляции.
//#define TimeHistHiLev    5 // Временной гистерезис для датчика верхнего уровня
//#define TimeHistLowLev   5 // Временной гистерезис для датчика нижнего  уровня   20
////#define TimeHistDryLev   40 // Временной гистерезис для датчика сухого   уровня
////#define TimeHistBlock    20
////#define   BlockUst       900
////#define   LevelUst       900  // Порог срабатывания датчиков уровня в битах
////#define   IsolUst        380  // Порог срабатывания датчика сопротивления изоляции в битах
//#define   ValueLimited   9990  // Ограничитель значения изменяемой уставки Value
//#define   Y2diff          30  // Значение Y2 для калибровки по диффзащите
//
//// Константы определяющие сегменты Flash памяти, где хранятся уставки и калибровки
//#define Flash_SegA 0x1000 // Рабочий сегмент,   1040
//#define Flash_SegB 0x1080 // Резервный сегмент  10C0
//          // Смещения в длинной в  слово от начала сегмента
//#define Contr1        0
//#define Adress        1  // Для вызова адреса с массива Flash
//
//#define Imax1kVt      2   // 1 - уставка защиты по току Iмах (1 кВт двигатель)
//#define Icx1kVt       3   // 3 - уставка защиты по току сухого хода Iсх (1 кВт двигатель)
//#define TauI          4   // 6 - уставка постоянной времени защиты по току (Iн)
//#define PodOtkSelSens 5   // 9 - уставка подача или откачка и выбор датчика ( оЭ=0 - откачка
//                          // Электрод(Э)/ПЕ=1-подача ЭКМ/ПЭ=2-подача(Э)/оП(лрочие)=3 )
//#define DeleyStartN   6   //Задержка перед пуском насоса в регулировании по уровню 50*200(Period)=10000 ms=10s
//#define DeleyStopN    7  //Задержка перед остановом насоса в регулировании по уровню 50*200(Period)=10000 ms=10s
//#define PowerMotor    8   // 15 - выбор номера кольца тока (1/2/3/4)
//  // Калибровки дифзащиты
//#define X1Diff        9   // 30 - X1 диф   фзащиты
//#define X2Diff       10   // 31 - X2 диффзащиты
//#define IdiffMax     11   // 8 - уставка защиты по дифф току
//                          // Калибровки
//      //Входные сигналы для первого поддиапазона(Большой коэффициент усиления)
//#define X1A1         12    // 18 - X1 фазы А
//#define X2A1         13    // 19 - X2 фазы A
//#define X1B1         14   // 22 - X1 фазы B
//#define X2B1         15   // 24 - X2 фазы B
//#define X1C1         16   // 26 - X1 фазы С
//#define X2C1         17  // 28 - X2 фазы С
//
//#define TimeCX       18  // 30 -
//#define UstZach1     19  //Уставка для регулирования температуры и влажности
//#define kol_zap      20 //UstZach->kol_zap Кол.запуск за 4 мин  21 04 2018
//#define IsolUst1     21  // Порог срабат.датчика сопротивл. изоляции  или Пл.Пуска в битах
//#define LevelUst1    22  // 10 - уставка выбор датчика (ЭКМ =0/Электрод=1/Итальянский=2)
//#define TK_A         23  // 34 - WD - запоминание режима TKA во Flash
//#define samozap      24  //Cамозапуск  21 04 2018 (UstZach3-> samozap), ранее Kb2
//#define UstZach2     25
//#define PP_Isol      26  //Выбор Плавного Пуска или Изоляцию
//#define ZD_Avar_CX   27  //Задержка включения аварии датчика СХ
//#define Ust_PP       28  //Уставка для Плавного Пуска
//#define Parol_uz     29  //Пароль пользователя 25 11 2019
//#define ver_prj      32  //версия проекта
//#define Tkz          33   // Запись аварии во Flash (т.е. KTZ)
//#define Contr3       34   //Указатель, равный количества записей уставок во Flash
//                         //Хранение K10 - количество включений двигателя, запом. при аварии
//#define Contr4       35   //время рвботы в час
//#define IndArr0      36   // Ток Ia при возникновении аварии при пере/недогрузке
//#define IndArr1      37   // Ток Ib при возникновении аварии при пере/недогрузке
//#define IndArr2      38   // Ток Ic при возникновении аварии при пере/недогрузк
//#define Contr2       39   //
//#define UstZach      34   //UstZach->.. 25 04 2018, свободно
//#define kol_faz      30   //Кол.фаз и датчиков тока  21 04 2018
//#define UstZach3     35   //UstZach3  25 04 2018, свободно
//#define CRC1         40   //СRC массива arr для уставок и записываемых
//                          //параметрах при перезапусках,если KTZ!=0
//#define PrZ          41  //Предел записи в массив arr
//
//#pragma memory=constseg(INFO)
//const unsigned int arr[] @ Flash_SegA ={101,0x0002,3000,0,90,2,1,1,3,4,248,50,//133/50mA(400A),188/50mA(100A),235/50mA(25A)  //Уставки //WAS 0xFFFF - 1*256+0x21
//                                  //      0,    1,   2, 3, 4,5,6,7,8,9, 10,11
//                                  //     [0]=Контр Flash
//                                  //           [1]=АДР МБ
//                                  //               [2]=Iмах
//                                  //                   [3]=Iмin
//                                  //                       [4]=Tнагр
//                                  //                         [5]=0 откачка,=2 подача
//                                  //                           [6]=Тзадержки ВКЛ по уровню
//                                  //                             [7]=Тзадержки ОТКЛ по уровню
//                                  //                               [8]= типоразмер
//                                  //                                 [9]=X1 диффзащиты
//                                  //                                     [10]=X2 диффзащиты
//                                  //                                     [11]= уставка защиты по дифф току
//      # ifdef Dt_nov
//                       2,441,1,440,3,442, //441,440,442    //130ед/300A
//                   // 12, 13,14,15,16,17
//                   //[12]=X1 тока фазы А
//                   //    [13]=X2 тока фазы A
//                   //       [14]=X1 тока фазы B
//                   //          [15]=X2 тока фазы B
//                   //             [16]=X1 тока фазы C
//                   //                [17]=X2 тока фазы C
//         # else
//                       2,660,1,660,3,660,
//        # endif
//      #ifdef TK112M
//                   254,
//       #else
//        #ifdef ZaschTV
//                   254,
//       #else
//                   10,
//                //[18]=TimeCX задержка сброса по сух.ходу
//       #endif
//     #endif
//                   4,5,
//                //[19]=UstZach1 -> Kz5 уставка по  Т и Влажности
//                //  [20]= UstZach->kol_zapkol_zap, Кол.запуск за 4 мин
//       //#ifndef Ppusk //WAS
//                   380,   //WAS 21 //Уставка контроля Изоляции
//      //#else   //WAS
//      //           700,  //WAS 21 -плавный пуск
//      //#endif
//                  1000,  // [22]= Порог срабатыв. датчиков уровня
//                     1,  //  [23]= Режимы управления Р=1(руч.реж Р),А=2,Д=3...
//                     0,  //  [24]= уставка UstZach3 -> samozap, ранее Kb2
//    #ifndef EnableNasos
//                     0, // [25]= включить насос //UstZach2- Kz8
//   #else
//                     3, // [25]= отключить насос
//
//   #endif
//                     0,10, 700, 1234, 1, 0, 50203,
//              //WAS 26,27,  28, 29, 30,31,32,
//              //   [26]= 1, выбран Пл.Пуск,=0 выбрана Излдяция
//              //      [27]= ZD_Avar_CX - Задержка включения аварии датчика СХ
//              //           [28]= = 700, Уставка для Пл.Пуск
//              //               [29]=Пароль,  25 11 2019
//              //                   [30]=kol_faz(Кол.фаз, т.е.1фаза,3фазы и 2 датч.,3фаз и 2 датч)
//              //                      [31]=рез
//              //                        [32]=ver_prj?,версия проекта
//                     0,  2, 255,256,257,16, 33, 2286 //55531
//              //WAS 33, 34, 35, 36, 37, 38,  39, 40
//              //   [33]= Tkz(Авар.знач. TKZ во Flash)
//              //       [34]= Contr3
//              //           [35]= Contr4
//              //               [36]=IndArr0 - запись тока Ia при Аварии
//              //                   [37]=IndArr1 - запись тока Ib при Аварии
//              //                       [38]=IndArr2 - запись тока Ic при Аварии
//              //                           [39]=Пароль
//              //                              [40]=СRC
//};
//const unsigned int arr1[] @ Flash_SegB ={101,0x0002,3000,0,90,2,1,1,3,4,248,50,//133/50mA(400A),188/50mA(100A),235/50mA(25A)  //Уставки //WAS 0xFFFF - 1*256+0x21
//                                  //      0,    1,   2,  3,4, 5,6,7,8,9, 10,11
//                                  //     [0]=Контр Flash
//                                  //           [1]=АДР МБ
//                                  //               [2]=Iмах
//                                  //                   [3]=Iмin
//                                  //                       [4]=Tнагр
//                                  //                         [5]=0 откачка,=2 подача
//                                  //                           [6]=Тзадержки ВКЛ по уровню
//                                  //                             [7]=Тзадержки ОТКЛ по уровню
//                                  //                               [8]= типоразмер
//                                  //                                 [9]=X1 диффзащиты
//                                  //                                     [10]=X2 диффзащиты
//                                  //                                     [11]= уставка защиты по дифф току
//      # ifdef Dt_nov
//                       2,441,1,440,3,442, //441,440,442    //130ед/300A
//                   // 12, 13,14,15,16,17
//                   //[12]=X1 тока фазы А
//                   //    [13]=X2 тока фазы A
//                   //       [14]=X1 тока фазы B
//                   //          [15]=X2 тока фазы B
//                   //             [16]=X1 тока фазы C
//                   //                [17]=X2 тока фазы C
//         # else
//                       2,660,1,660,3,660,
//        # endif
//      #ifdef TK112M
//                   254,
//       #else
//        #ifdef ZaschTV
//                   254,
//       #else
//                   10,
//                //[18]=TimeCX задержка сброса по сух.ходу
//       #endif
//     #endif
//                   4,5,
//                //[19]=какая-то защита UstZach1
//                //  [20]=какая-то защита UstZach
//       //#ifndef Ppusk //WAS
//                   380,   //WAS 21 //Уставка контроля Изоляции
//      //#else   //WAS
//      //           700,  //WAS 21 -плавный пуск
//      //#endif
//                  1000,  // [22]= Порог срабатыв. датчиков уровня
//                     1,  //  [23]= Режимы управления Р=1(руч.реж Р),А=2,Д=3...
//                     0,  //  [24]= уставка UstZach3 -> samozap
//    #ifndef EnableNasos
//                     0, // [25]= включить насос //UstZach2-?
//   #else
//                     3, // [25]= отключить насос
//
//   #endif
//                     0, 10, 700, 1234, 1, 0, 50203,
//              //WAS 26,27,  28,  29, 30,31,32,
//              //   [26]= 1, выбран Пл.Пуск,=0 выбрана Излдяция
//              //      [27]=  ZD_Avar_CX - Задержка включения аварии датчика СХ
//              //           [28]= 700, Уставка для Пл.Пуск
//              //               [29]=Пароль,  25 11 2019
//              //                     [30]=kol_faz(Кол.фаз, т.е.1фаза,3фазы и 2 датч.,3фаз и 2 датч)
//              //                       [31]=рез
//              //                          [32]=версия проекта
//                     0,  2, 255,256,257,16,33,2286 //55531
//              //WAS 33, 34, 35, 36, 37, 38, 39, 40
//              //   [33]= Tkz(Авар.знач. TKZ во Flash)
//              //       [34]= Contr3
//              //           [35]= Contr4
//              //               [36]=IndArr0 - запись тока Ia при Аварии
//              //                   [37]=IndArr1 - запись тока Ib при Аварии
//              //                       [38]=IndArr2 - запись тока Ic при Аварии
//              //                           [39]=Пароль Contr2
//              //                              [40]=СRC
//};
//#pragma memory = default
//char SL_Master; //=1 Станция является Мастером, =1 ..Плдчиненным
//char KTZ; //переменная содержащая код типа защиты
//          // 0 - параметры в норме
//          // 1 - ассиметрия
//          // 2 - перегрузка
//          // 3 - сухой ход по нагрузке
//          // 4 - изоляция
//          // 5 - дифференциальная защита
//          // 6 - cухой ход по датчику
//          // 7 - неисправность датчика
//          // 8 - неисправность по самодиагностике (пока не реализована)
// // Номер режима индикации после которого следуют служебные режимы индикации
//#ifdef EnableNasos
//#ifndef DiffZasch
// #define NumIndM 26  // если насосом управляем //18->25
//#else
// #define NumIndM 26  // если насосом управляем //18->25
//#endif
//#else
// #define NumIndM 26 // если насосом не управляем //13->25
//#endif
//#define NumIndM1 26 //NumIndM_max+1(19+1) Общее кол. режимов индик.//20->25
// unsigned long Indarr_naysum_3,Indarr_naysum_4,Indarr_naysum_5,Indarr_naysum_6; //усреднение
//
//char INDMODE; // переменная содержащая номер режима индикации
//             //Список экранов дисплея ТК112
//          // 1 - ГлавныйЭлектородвигатель (ЭД) включён/Выключен  On/OFF
//          // 2 - *,Текущий ток фазы A     (с настройкой)
//          // 3 - *,Teкущий ток фазы B    (с настройкой)
//          // 4 - *,Текущий ток фазы С    (с настройкой)
//          //5 - Уставка: Выбор режима работы станции Р-ручн.,А-автомат.,Д-дист
//          //6 - Уставка Iн ток нагрузки (защита по току) , А
//          //7 - уставка Icх - ток сухого хода (защита по току, А
//          //8 - Вид работы для регулятора и Выбор датчика (оЭ/ЭКМ/Электоды/др)
//          //9 - *,Уставка: Типоразмер (или выбор кольца)
//          //10 -*, Уставка: постоянная времени для защиты по току (Iн и Icх), с.
//          //11 -*, Уставка:фазность
//          //12 -*, Уставка:Сопротивление изоляции или то же при Плавном Пуске
//          //13 -*, Уставка:Самозапуск
//          //14 - Асимметрия,%
//          //15 - Rизол. - сопротивление изоляции, биты
//          //16 -Rcx, кОм - сопротивление датчика сухого уровня, биты
//          //17 -Rву, кОм - сопротивление датчика верхнего уровня, биты
//          //18 -Rну, кОм - сопротивление датчика нижнего уровня, биты
//          //19 -*, Уставка:Порог срабатыв. датчиков уровня
//          //20 -Уставка:Тзадержки ВКЛ по уровню
//          //21 - Уставка:Тзадержки ОТКЛ по уровню
//          //22 - Уставка:Кол.запуск. за 4 мин
//          //23 -*, Уставка:TimeCX задержка сброса по сух.ходу
//          //24 -*, Уставка: Адрес МБ
//          //25- Параметр: Время работы двигателя в час
//
//          //??? 17 Уставка:задержка перед пуском насоса в регулировании по уровню,c( 50*200(Period)=10000 ms=10s)
//char INDMODE_old=0;//для перекл. тек. экрана в 0
//
//char TaskMB = 2; //1 - Start от МБ, =2 - Stop,
//char Pusk_On=0;  //=1 - Start,=0- Stop, от кн.Start в режиме РУЧНОЙ
//char TaskKTZ = 0;
//char CounterKTZ = 0;
//char StateMB =1; //1 - Stop, 2 - Start
//unsigned int SetpointMB=0; //Принятая уставка по МБ
//char ADR_SetpointMB=0;    //Адрес принятая уставки по МБ
//unsigned int Parol_MB=0;  //Принятый пароль по МБ
//char Parol_bt=0;          //Пароль: =1 установлен, =0 не установлен;
//char Rec_Setp_MB=0;  //Запрос на ввод принятой по МБ уставку;=0 -нет запроса,
//                       //=1 уставка с паролем,=2 уставка без пароля
//char Cmd_grup; //переключатель групп уставок МБ без пароля: =1 уставки и =2 команды
//char Comd_Driv_d;//подмена команды Command_Driv=1для реж ДИСТ-АВТ
//unsigned int TimeCode105=0,TimeCode106=0,TimeCode110=0; //Счетчики ответов станции для Модема
//char CommonStatus;    // Байт содержащий, служебные биты программы
//                      // бит 0 - индикатор определения состояния двигателя по току
//                      //         1 - двигатель включён;;
//                      //         0 - двигатель выключен;
//                      //  бит 1 - флаг отсчета таймером A 1 ms
//                      //      0 - нет пока 1 ms (сбрасывается в прерывании  АЦП)
//                      //      1 - есть 1 ms (устанавливается в обработчике прерывания таймера A)
//                      //  бит 2 - сигнал запуска двигателя по кнопке Пуск
//                      //           при KTZ=0 и выполнении условий пуска алгоритма насос
//                      //      0 - двигатель не запускаем
//                      //      1 - двигатель запускаем
//                      //  бит 3 - Разрешения запрещения работы алгоритма "Насос"
//                      //      0 - алгортим "Насос" выключен (сбрасывается при нажатии кнопки Стоп )
//                      //      1 - алгоритм "Насос" работает (устанавливается при нажатии кнопки Пуск )
//                      //  бит 4 - команда сброса по интерфейсу
//                      //          1 - сделать сброс; 0 - не делать сброс
//                      //        По этой команде запрещаются прерывания таймера A, что приводит к срабатыванию WDT
//                      // бит 5 - флаг обновления вывода значений уставок на индикатор при изменении их
//                      // по внешнему интерфейсу
//                      //   0 - не обновляем значение уставки, 1 - обновляем значение уставки
//                      // бит 6 - вспомогательный бит для перехода в сервисные режимы индикации
//                      // бит 7 - вспомогательный бит индицирует вход в прерывание АЦП
//
// char LevelStatus ;   // Переменная содержащая вычесленное состояние датчиков уровня (инфо на индикатор)
//                      // для индикатора и интерфейса
//                      // 0 - норма (на индикаторе символ "-")
//                      // 1 - уровень верхний  (на индикаторе символ "H")
//                      // 2 - уровень нижний   (на индикаторе символ "L")
//                      // 3 - уровень аварийный (на индикаторе символ "A")
//char LevelStatusNew;  // Переменная с измеренными значениями уровня
//char LevelStatus_;    // Переменная с вычисленными значениями уровня
//                           // 0 бит - состояние нижнего уровня (1- контакт замкнут; 0- разомкнут)
//                           // 1 бит - состояние верхнего уровня
//                           // 2 бит - состояние аварийного уровня
//
// unsigned int *pword1;     // указатели на слова
// unsigned int *pword2;
// char cntT0,cntTM,cntTL,TKA,Tiporazmer;
// char TKA_MB;//режим работы текущий станции,передаваемый на запросы МБ
// char TaskMB_RAD;//Задание станции текущее,передаваемый на запросы МБ
// char Err_MB;      //Ошибка в МБ при посылке запросов 18 11 2019
// char Exc_code_MB; //Код Ошибки в МБ при посылке ответов при наличии Err_MB 18 11 2019
// char cntTA1,cntTA2,TimeStart;  // Счетчик интервалов в 1 ms . Инкременртируется
//                                       //в обработчике прерываня Таймера А
// char cntTA3; //cчетчик 3 таймера А,обслуживающего задержками прием ModBus (RX)
// char cntTA4;//счетчик прерываний в ADС12 для усредненя замеров аналог. параметров
// char TimePuskStop,TimeCXNasos,TimeCXN;       // Таймер пуска или останова.
// //WAS
// //char g3,ww1;
// char  Samo_zp;//Повторитель самозапуска в ОЗУ
// unsigned int cnt_sbr_scrn; //Счетчик сброса n-го экрана в 0-й
// //char  Ind_faz=0;
// char  Rej_Pod=0, Rj_VU_P=0 /*подчин.режим ВУ*/,Rj_VU_N=0 /*неиспольз.режим ВУ*/;
// //WAS_10_1  для контр.перемещ. указат.стека
//  //unsigned int SP1,dSP_p=0;
//  //int dSP;
// //WAS_10_2  для контр.перемещ. указат.стека
// unsigned int TimeStopNasos;//,TimeStopN;// Инкременртируется в конце глобального цикла каждые 200 ms
//
// //WAS и Прием от/в модема   нач.
// char K5;// (K5 & 0x01) - разрешение прерывания по приему Modbus
// char NU,VU,SU; //Уровни для ответа по МБ        //WD
// char St_Driv; //Состояние мотора                //WD
//char VU_NU_SX; //Битовые коды уровней для ответа //WD
// char i,i1,i2,i3,i4,i5,i6,i7,K2;
// char l2,l6,l7,Test1;
// char Kz11; //Вписывание данных приема
// char Kb5,Ks2_1,Ks2_2,Ks3_1;
// char Ks1_1; //WAS переменная определяет команды и режимы, задаваемые с модема
// char Ks1_2; //WAS переменная определяет дополнительные условия задаваемые с модема
// unsigned int i10=0; //Cчетчик циклов отсутствия ответов Подчтненного по МБ
// char SBUFrx0=0;   //Повторитель SBUFrx[0] для SL_Master
// char Temp_w; //
// char Ppusk1; //Выбор Плавного Пуска, =1 выбран Пл.пуск,=0 не выбран,
//                         //но выбрано изммерение Изоляции
// char IndArray6;
// #define ColPdByt1       11// Количество передаваемых байт /вместе с контрольной суммой/ master
//char ADR1;             //ADR1-адрес подчиненного;
//char ADR_SMI2=0x10;    //Адрес индикатора СМИ2;
//char Quer_MB=1;
//unsigned int Temp2;// Временная переменная применяется в различных местах программы
//char ww=0; //WAS_ для инициализации массива arr
////char Hold_Reg[4];       //Массив для выдачи данных Мастеру db
////unsigned int Hold_Reg[10]; //25 06 2018
//char SBUFfl[4];         //Массив принятыхи данных от Мастера
//char SBUFtx [35];   /*transmit buffer for UART */
//char SBUFrx [25];   /*receive buffer for UART */
//
////Прием от модема
//char Funk_Mod;           //Принятая функция
//unsigned int N_ADR_Reg;  //начальный адрес регистра
//unsigned int Quant_Reg;  //Количество регистров
//unsigned int Hold_Reg[10]; //25 06 2018 //с 7 до 10 18 11 2019 c переходом на МБ
//unsigned int RJ_Mod;             //Заданный режим станции (только для ДИСТАНЦ. режима):
//                         //      =31 -работа по команде диспетчера
//                         //       =32 -автоматич.работа(по датч.)
//                         //       =33 -работа по команде диспетчера, кнопкам Пуск и Стоп
//                         //           и сигналу(кнопке) Пожар
//                         //игноррируется при режиме РУЧНОЙ и АВТОМАТИЧЕСКИЙ
//char Task_Station;       //Заданное задание станции (только для ДИСТАНЦ. режима):
//                         //  =1 - запустить автоматич.работу станции
//                         //  =0 - остановить автоматич.работу станции
//                         //игноррируется при режиме РУЧНОЙ и АВТОМАТИЧЕСКИЙ
//
//
//char Task_Stn_Zdn_MB;       //заданное задание станции для ответа по МБ
//char TKA_zdn;                //Заданный режим,выполняемый станцией
//char Command_Driv;           //Команда ВКЛ/ОТКЛ мотор.Игнорируется при
//                             //режиме станции АВТОМАТИЧЕСКИЙ
//char Reset_Protect1;         //Сброс защиты
//char Reset_Protect2;         //Сброс ограничения сбросов защиты,счетчк=0
////WAS Прием от/в модема кон.
////Для звпрлнения ответа по функциии 106
//char Ogr_Kol_Vkl;//Ограничение на кол. включений Двигат. за 4 мин
//char Assim_O_Prz; //Асиметрия в %
//                  //Assim_O_Prz = (Assim_O / (UstImax/2)))* 100 %
//char Quer;//запрос от мастер
//#ifndef DiffZasch
// unsigned int Kb3;
//#endif
// unsigned int K8,K14,TimeStartNasos;//,TimeSN;// Таймер задержки пуска насоса при управлении алгоритмом насос
////unsigned int TimeContr1,TimeContr2;// Таймер задержки пуска насоса при управлении алгоритмом насос
// char PerNetCount;         // Счётчик количества периодов
// unsigned int NumSamples,cntTA0;  // Cчётчик количества измерений
// unsigned int Value,Value1,LevelUst,IsolUst,UstImaxDiap;//,UstImax;//,UstIcx;
//// Переменные для эспонентциального фильтра
//unsigned int PhaseMax_O, PhaseCx_O, Assim_O;        // Выходные значения фильтров по максимальному току и току сухого хода  и ассиметрии
//signed int   RemPhaseMax, RemPhaseCx, RemAssim;     // Остатки вычислений  фильтров по максимальному и минимальному токам и ассиметрии
//
//char TimeHi,TimeLow,TimeTr;     // Таймера гистерезиса для датчиков уровня
////char TimePuskStopMax;
//unsigned int Isol_O,TauTEMP,TimeDry;                                 // Выходное значения фильтров по изоляции
//signed int   RemIsol;                                // Остаток вычисления  фильтра по изоляции
//
//unsigned int IndArray [8];    // Данные выодимые на индикатор после перерасчёта калибровок
//                              // 0 - Ток фазы А
//                              // 1 - Ток фазы В
//                              // 2 - Ток фазы С
//                              // 3 - Диф. ток
//                              // 4 - Сопротивление изоляции (битовое представление)
//                              // 5 - Сопротивление нижнего уровня (битовое представление)
//                              // 6 - Сопротивление верхнего уровня (битовое представление)
//                              // 7 - Сопротивление аварийного уровня (битовое представление)
//
//char MeasureControl;          // Байт управления для обработчика прерываний АЦП
//                              // 0 - измеряем только токи на 2-ух фазах
//                              // 1 - измеряем токи на 2-ух фазах и диффзащиту
//                              //(Устанавливается по прерыванию таймера A3,
//                              // cбрасывается обработчиком прерывания АЦП)
//                              // 2 - измеряем все параметры
//                              //(для вычислений используем только диффзащиту,
//                              // сопротивления электродов, и изоляцию)
//                              // 3 - ничего не измеряем останавливаем AЦП.
//
// //char g5; //не используется
//char g1,g2,g3;
//char l1; //WD  ????
//char Px,PCx,K6,K7,K9, /*K10,*/ K11,K12,K13;
//char K10; //Текущее значение включений двигателя от начала отсчета интервала 4 мин.
//unsigned int Kb1;//Счетчик отсчета интервала 4 мин для контроля числа включ. двиг.
//char K4;  // Задержка при включении насоса
//char Kz1,Kz2,Kz3,Kz4,Kz5,Kz6,Kz7,Kz8,Kz9;//,Kz10;
//char Kb2; //Повторитель Самозапуска, т.е. Kb2&1 - это самзапуск
//char Faz; //Фазность двигателя: =1 3-х фазный с 2-я датчиками;
//          //                    =2 3-х фазный с 3-я датчиками;
//          //                    =3 однофазный с 3-я датчиками;
//char Kb2_1;      //Безусловне выполнение самозапуска 09 05 2018
//char Cr_Tpr=0; //=1 производится корректировка Типоразмера WAS13 05 2018
//char More_d,Less_d; //Флаги срабвтывания кнопок Больше и Меньше
//unsigned int DiffLevel;               // Уровень диффзащиты
// // Переменные для измерения дифф. тока
//#ifdef DiffZasch
// unsigned int DiffZerro,DiffZerro1;      // Вычисленный нуль дифзащиты
// unsigned int DiffMid;        // Найденное значение диф. тока
// char K1,K1_1,K2,K3;
//#endif
//// signed int x;
//// signed long Temp2;
//char Tim_KTZ_6=0; //Промежуточная переменная для задержки формирования аварии по датчику СХ
//unsigned long Diffsum; // Интегральная суммы значений измерений АЦП для дифференциального тока //WAS_6 восстановлено
////unsigned int DiffCurrent; // Значение дифференциального тока в битах
// unsigned int Temp; //WAS // Временная переменная применяется в различных местах программы
// //char Tempp;               // Временная переменная применяется в обработчике прерываний по АЦП
//char Point4; //Положение запятой в параметре измеренного тока
//  //Константы перевода десятичных цифр в их изображении "портрет" для индикатора СМИ2
//                         //      0     1   2    3    4    5    6    7    8    9  . -
//const unsigned char portr[12]={0xFC,0x60,0xDA,0xF2,0x66,0xB6,0xBE,0xE0,0xFE,0xF6,1,2};
//
//
//unsigned int CRC_16(unsigned char *Buffer,unsigned int length);
//
//void Init (void);         // Функция начальной инициалицации устрйства
//void Button (void);       // Функция опроса кнопок
//void MeasureAndCalcCurrent (void); // Функция измерения на протяжении 5- ти периодов
//                                   // силы тока и вычисления согласно калибровок
//
//// Функция расчёта выходного параметра по 2 калибровочным точкам (x1,y1) и (x2,y2)
//// Формула y=((y2-y1)*(x-x1))/(x2-x1) + y1
//signed int CalcOut (signed int Input,unsigned int Offset);
//
//// ФУНКЦИЯ ЗАПИСИ ВО ФЛЕШ УСТАВОК И КАЛИБРОВОК
//void write_Flashw (unsigned int value, char Offset );
//
//void Answer(void);//Функция ответа на запросы по интерфейсу
//void Command_MB (char Cmd_grup); //установка принятых команд с МБ 27 11 2019
//
//// Обработчик прерывания по фронту на ноге P1.7. Применяется для отсчёта точной длительности измерений
//// interrupt [PORT1_VECTOR] void Port1_ (void) //WAS_1
//#pragma vector = PORT1_VECTOR                  //WAS_1_1
//__interrupt void Port1_ (void)                 //WAS_1
//{ P1IFG =0;        // Сброс флага прерываний
//  if(cntTA1>5){PerNetCount++;cntTA1=0;}
//}
// // Обработчик прерывания по фронту на ноге P                2.7. Применяется для отсчёта точной длительности измерений
//// interrupt [PORT2_VECTOR] void Port2_ (void) //WAS_2
//#pragma vector = PORT2_VECTOR                  //WAS_2_2
//__interrupt void Port2_ (void)                 //WAS_2
//{ P2IFG =0;      // Сброс флага прерываний
//if((!(g3))&&(Kz6))
// {Kz6=0;if(KTZ)K10=0;
// #ifdef Ppusk
// if(((KTZ)&&(!(Kz8&4)))
// #else
// if(((!(Kz8&4))&&(((KTZ)&&(KTZ!=4)))||((KTZ==4)&&(Kz9>10)))
//#endif
// ||((K10)&&(Kb3<6000))
// )
// write_Flashw (KTZ,Tkz);}
//}
//
//// The interrupt handler from Timer A0
//// interrupt[TIMERA0_VECTOR] void Timer_A (void)   //WAS_3
//#pragma vector = TIMERA0_VECTOR      //WAS_3_3
// __interrupt void Timer_A (void)      //WAS_3
//{   cntTA0++;cntTA1++;                 // Increment  the counter of ticks 1 ms
// //WAS_NSZ1 нач.
//  //Сброс переменных для измерения тока
// if(cntTA0<4){cntTA4=Indarr_naysum_3=Indarr_naysum_4=Indarr_naysum_5=Indarr_naysum_6=0;}
// //WAS_NSZ1 кон.
//
//    CommonStatus|=2;          // Устанавливаем бит-флаг отсчёта 1 ms
////    if(cntTA0>420){P4OUT=1;KTZ=8;return;}
//    WDTCTL=WDT_MRST_32;       // Сбрасываем WDT
//#ifdef EnableConvert
//#ifdef DiffZasch
//    // Проверка дифзащиты
//    if (P4OUT&1) goto ExitTimer; // если двигатель не включён, то диффзащиту не проверяем
//    if (DiffLevel>2048)  goto ExitTimer;
//    if (((signed int)ADC12MEM3-(signed int)DiffZerro)>=(signed int)DiffLevel)
//   { if (K3){K1++;K3=0;}K2=7;goto ExitTimer;}
//    if (((signed int)DiffZerro-(signed int)ADC12MEM3)>=(signed int)DiffLevel)
//     {if( K2){K1++;K2=0;}K3=7;}
//   ExitTimer:if((K1>4)&&(TimePuskStop>=TimePuskStopMax))//?
//   {KTZ=5;if(P3IN&0x40) P4OUT=1;}
//    if(K2||K3) cntTA2++;
//    if (cntTA2>=14){if(K1>K1_1){K1_1=K1;}else{K1=K1_1=K2=K3=0;}cntTA2=0;} //14
//#endif
//#endif
// //********************************
// //Обработка принятых сообщений ModBus
//if(K4>=4)
//  {cntTA3++;
//   if(cntTA3>=6)cntTA3=6;}   // ограничить счетчик задержки по приему
//if(cntTA3==4)                    //ЗАДЕРЖКА для паузы для нового сообщ?? только при счетчике==4 обработать
// {cntTA3=6;
//   if(i1)                      //Принято сообщение по ModBus(см Обработчик прерывания по приёму)
//    {if(SL_Master)SBUFrx[0]=SBUFrx0;
//      Temp=CRC_16((unsigned char*)&SBUFrx[0],i1+1);       //контрольная сумма контрольная сумма cообщ. ModBus размером i1+1
//     if((Temp)||(l2==2)){IE1|=URXIE0;ME1|=URXE0;K5&=(~1);} //Сбой связи.Разрешить прерывание по приему в регистр ModBus (ТХ); K5-???
//     if(!(Temp))                                          //Связь нормально.Контр. сумма сообщ.КС (КС=Temp) Temp=0,т.е. нормально
//     {
//         if((SBUFrx[0]==ADR1)||(SBUFrx[0]==ADR_SMI2))                           //принято сообщение от мастера для данной станции
//           {/*if(TKA&8) */                                 //TKA&8 -???
//           /* {*/
//             K14|=0x40;i5=SBUFrx[2]/2;i6=3; Quer_MB=1;
//             if(SL_Master){SBUFrx[0]=0;K5&=(~1);}
//             goto n1; /*}*/   //???? обнуление адреса и признаков отсутствия связи
//           }
//          else goto n3; //принято сообщение, которое не нужно обрабатывать
//
//      n1:
//   //= = //= = //= = //= = //= = Мастера или Подчиненный//= = //= = //= = //= = нач.
//       //Станция является Подчиненный
//      if(!(SL_Master))
//       {  //обработка принятго сообщения от Мастера
//        //заполниние буфера приема:
//        // Принятое сообщение от Мастера:                    нач
//        //Общее для всех функций нач.
//        //ADR1= SBUFrx[0]; //Адрес Подчиненного
//       //Нач. общее начало для запросов функций 0x10 и 0х3
//        Funk_Mod=SBUFrx[1]; //Принятая функция
//         Err_MB=0;
//        //Формирование аварии нарушение номера функции,если есть то =1
//        if((Funk_Mod!=0x03)||(Funk_Mod!=0x06)||(Funk_Mod!=0x10)||
//           (Funk_Mod!=0x16)) ( Err_MB=1);
//        //Формирование аварии нарушение номера функции,если есть то =1
//        N_ADR_Reg=(SBUFrx[2]<<8)+SBUFrx[3];  //начальный адрес регистров
//        //Предварительно установить аварию по отсутствию номера запрашиваемого
//        //регистра, т.е. Err_MB==0x02. Он будет сброшен, если в одной из
//        //запрашиваемых функций ниже он будет найдкн
//        Err_MB=0x02;
//        Quant_Reg=(SBUFrx[4]<<8)+SBUFrx[5];  //Количество регистров
//       //Кон. общее начало для запросов функций 0x10 и 0х3
//        //запросы ввода уставок без пароля
//        if((Funk_Mod==0x10)&&(N_ADR_Reg==0))
//         { Err_MB=0; //имеется нужный регистр
//           Cmd_grup=1;
//           Command_MB (Cmd_grup);
//         }
//
//        if((Funk_Mod==0x03)&&(N_ADR_Reg==0x0100))
//        {Err_MB=0; //имеется нужный регистр
//          i2=i2;} //пустая строка, т.к. SBUFrx[] заполнены
//       }
//       //Ввод уставки по МБ, которые храняться во Flash:
//      //производится проверка наличия введенного пароля,
//      //если да, то принятая уставка заносится в SetpointMB
//      //В дальнейшем она сбрасывается после записи во флаш
//       if((Funk_Mod==0x06)&&((N_ADR_Reg>=0x1000)&&(N_ADR_Reg<0x1200))){
//         Err_MB=0; //имеется нужный регистр
//         Temp=arr[Parol_uz];
//         SetpointMB=(SBUFrx[4]<<8)+SBUFrx[5]; //уставка
//         ADR_SetpointMB=SBUFrx[3];           //адрес уставки во Flash
//         ////Прием пароля
//        // if(SBUFrx[3]==255){Parol_MB=1234;Parol_bt=1;Rec_Setp_MB=0;SetpointMB=0;}
//         //Прием уставок без пароля
//         if((SBUFrx[3]==2)||(SBUFrx[3]==3)||(SBUFrx[3]==23))
//          {Rec_Setp_MB=2;           //удалено  if(SetpointMB)
//           //else Rec_Setp_MB=0;    //удалено
//          }
//          //Прием уставок с паролем
//          //if(Parol_MB==Temp)
//         if(Parol_bt)
//           { if((((SBUFrx[3]==1)||(SBUFrx[3]==2)||(SBUFrx[3]==30)||
//                 (SBUFrx[3]==18)||(SBUFrx[3]==26)||
//                 (SBUFrx[3]==28))||
//                ((SBUFrx[3]>=3)&&(SBUFrx[3]<9))||
//                ((SBUFrx[3]>=20)&&(SBUFrx[3]<23))))
//                 { Rec_Setp_MB=1;}
//           }
//       }
//           //В дальнейшем она сбрасывается после записи во флаш
//       if((Funk_Mod==0x06)&&((N_ADR_Reg>=0x1200)&&(N_ADR_Reg<0x1300))){
//         Err_MB=0; //имеется нужный регистр
//         Cmd_grup=2;
//         Command_MB (Cmd_grup);
//       }
//
//        i10=Kz11=0;
//    //Проверка задержки передачи после сброса
//    // и подготовка к передаче и передача Модему
//     if(K4>=4)
//      {}
//   }
//   n3:i1=0;
//   //сброс количество принятых байтов
//    l2=0;
//    if((!(l1))&&(K5&0x01))
//     {//Формирование ответа по Модбаc
//       IE1&=~URXIE0;ME1&=~URXE0;
//       //Станция является Подчиненный
//       if(!(SL_Master))
//        { SBUFtx[0]=ADR1;        //Адрес
//        //Ответ по Фкнкции 0x03 посылается после для проверки наличия значения
//        //стартового регистра, равного N_ADR_Reg=x0100;
//         if((Funk_Mod==0x03)&&((N_ADR_Reg>=0x0100)&&(N_ADR_Reg<0x0200)))
//         {SBUFtx[1]=0x03; //Функция
//          SBUFtx[2]=32;   //Количество байт
//          SBUFtx[3]=0;
//          SBUFtx[4]=TKA_MB; //режим текущий
//          SBUFtx[5]=0;
//          SBUFtx[6]=TaskMB_RAD; //задание текущее
//          SBUFtx[7]=0;
//          SBUFtx[8]=St_Driv;  //Cостояние мотора
//          SBUFtx[9]=0;
//          SBUFtx[10]=KTZ;      //Защита (наличие аварии)
//          SBUFtx[11]=0;
//          SBUFtx[12]=VU_NU_SX; //Битовые коды уровней
//          SBUFtx[13]=0;
//          SBUFtx[14]=Parol_bt; ////наличие пароля
//          Hold_Reg[0]=IndArray[0]; //I1
//          Hold_Reg[1]=IndArray[1]; //I2
//          Hold_Reg[2]=IndArray[2]; //I3
//          Hold_Reg[3]=Isol_O;      //    Измеренное сопротивление изоляции
//          Hold_Reg[4]=Assim_O_Prz; //         Измеренная асимметрия в %
//          Hold_Reg[5]=IndArray [7]; //         Измеренный  уровень CХ
//          Hold_Reg[6]=IndArray [5]; // Измеренный  нижний уровень НУ
//          Hold_Reg[7]=IndArray [6]; // Измеренный  верхний уровень ВУ
//          Hold_Reg[8]=arr[ver_prj]; //версия проекта
//          Hold_Reg[9]=TimeCode105; //счетчик обменов
//            //Выполнить перестановку местами байтов для Hold_Reg
//            // и записать их в SBUFtx[i2], начиная SBUFtx[10].
//            // Во время записи переставлять байты для записи местами,
//            // старший байт затем младший.
//           i2=15;i3=10;
//           for(i4=0;i4<i3;i4++)
//            {Temp2=Hold_Reg[i4];
//             SBUFtx[i2]=Temp2/256;
//             SBUFtx[i2+1]=Temp2%256;i2=i2+2;}
//         }
//
//         //Ответ на Одиночный просмотр уставок и параметров
//        if((Funk_Mod==0x03)&&((N_ADR_Reg>=0x0200)&&(N_ADR_Reg<0x0250))&&(!(Err_MB)))
//         {SBUFtx[1]=0x03; //Функция
//          SBUFtx[2]=2;   //Количество байт
//          if(N_ADR_Reg==0x0200)
//           {SBUFtx[3]=0;SBUFtx[4]=TKA;} //режим текущий
//          if(N_ADR_Reg==0x0201)
//          {SBUFtx[3]=IndArray[0]/256;SBUFtx[4]=IndArray[0]%256;} //ток I1
//          if(N_ADR_Reg==0x0202)
//          {SBUFtx[3]=IndArray[1]/256;SBUFtx[4]=IndArray[1]%256;} //ток I2
//          if(N_ADR_Reg==0x0203)
//          {SBUFtx[3]=IndArray[2]/256;SBUFtx[4]=IndArray[2]%256;} //ток I3
//          if(N_ADR_Reg==0x0204)
//          {SBUFtx[3]=0;SBUFtx[4]=arr[23];} //TKA , arr[23]
//          if(N_ADR_Reg==0x0205)
//          {SBUFtx[3]=arr[2]/256;SBUFtx[4]=arr[2]%256;} //Iн , arr[2]
//          if(N_ADR_Reg==0x0206)
//           {SBUFtx[3]=arr[3]/256;SBUFtx[4]=arr[3]%256;} //Iсх, arr[3]
//          if(N_ADR_Reg==0x0207)
//          {SBUFtx[3]=0;SBUFtx[4]=arr[5];} //Режим работы насоса, arr[5]
//          if(N_ADR_Reg==0x0208)
//          {SBUFtx[3]=0;SBUFtx[4]=arr[8];} //Типоразмер, arr[8]
//          if(N_ADR_Reg==0x0209)
//           {SBUFtx[3]=0;SBUFtx[4]=arr[4];} //Постоянная времени нагрева, arr[4]
//          if(N_ADR_Reg==0x020A)
//          {SBUFtx[3]=0;SBUFtx[4]=arr[30];} //Фазность двигателя, arr[30]
//          if(N_ADR_Reg==0x020B)
//          {SBUFtx[3]=0;SBUFtx[4]=Assim_O_Prz;} //асимметрия, Ac
//          if(N_ADR_Reg==0x020C)
//           {SBUFtx[3]=0;SBUFtx[4]=arr[24];} //Самозапуск, arr[24]
//          if(N_ADR_Reg==0x020D)
//          {SBUFtx[3]=arr[21]/256;SBUFtx[4]=arr[21]%256;} //контроль изоляции, arr[21]
//          if(N_ADR_Reg==0x020E)
//          {SBUFtx[3]=Isol_O/256;SBUFtx[4]=Isol_O%256;} //Измеренное сопротивления Изоляции
//          if(N_ADR_Reg==0x020F)
//          {SBUFtx[3]=0;SBUFtx[4]=VU_NU_SX;} //Наличие уровней NU/VU/SX или SUв бит:
//          if(N_ADR_Reg==0x0210)
//          {SBUFtx[3]=IndArray[7]/256;SBUFtx[4]=IndArray[7]%256;} //Измеренный уровень датчика СХ
//          if(N_ADR_Reg==0x0211)
//          {SBUFtx[3]=IndArray[6]/256;SBUFtx[4]=IndArray[6]%256;} //Измеренный уровень датчика VU
//          if(N_ADR_Reg==0x0212)
//          {SBUFtx[3]=IndArray[5]/256;SBUFtx[4]=IndArray[5]%256;} //Измеренный уровень датчика NU
//          if(N_ADR_Reg==0x0213)
//           {SBUFtx[3]=arr[22]/256;SBUFtx[4]=arr[22]%256;} //Уставка порога срабат изоляции arr[22]
//          if(N_ADR_Reg==0x0214)
//          {SBUFtx[3]=0;SBUFtx[4]=arr[6];} //Уставка задерж вкл. ЭД по уровню arr[6]
//          if(N_ADR_Reg==0x0215)
//          {SBUFtx[3]=0;SBUFtx[4]=arr[7];} //Уставка задерж откл. ЭД по уровню arr[7]
//          if(N_ADR_Reg==0x0216)
//           {SBUFtx[3]=0;SBUFtx[4]=arr[20];;} //Уставка колич. включ двиг. arr[20]
//          if(N_ADR_Reg==0x0217)
//          {SBUFtx[3]=0;SBUFtx[4]=arr[18];} //Уст задерж восстанч СХ после Аварии,arr[18]
//          if(N_ADR_Reg==0x0218)
//          {SBUFtx[3]=0;SBUFtx[4]=ADR1;} //Адрес в сети Модбас:Подчиненный)
//          if(N_ADR_Reg==0x0219)
//           {SBUFtx[3]=0;SBUFtx[4]=arr[26];} //Выбор контр сопротизол/Пл.Пуск arr[26]
//          if(N_ADR_Reg==0x021A)
//          {SBUFtx[3]=arr[28]/256;SBUFtx[4]=arr[28]%256;} //Уставка для запуска двиг с Пл/Пуск arr[28]
//          if(N_ADR_Reg==0x021B)
//          {SBUFtx[3]=0;SBUFtx[4]=Parol_bt;} //наличие введенного пароля,=1 ДА,=0 НЕТ
//          if(N_ADR_Reg==0x021C)
//          {SBUFtx[3]=arr[ver_prj]/256;SBUFtx[4]=arr[ver_prj]%256;} //версия проекта
//          if(N_ADR_Reg==0x021D)
//          {SBUFtx[3]=0;SBUFtx[4]=TimeCode105;} //счетчик обменов
//          i2=5;
//         }
//
//     //==//==//==//==//==Подготовка ответа по функции 0x10 ==//==//==//==//нач
//            //Ответ функции 0х10 при отсутствии ошибки Err_MB
//          if((Funk_Mod==0x10)&&(N_ADR_Reg==0)&&(!(Err_MB)))
//          { SBUFtx[1]=Funk_Mod;     //Функция
//            SBUFtx[2]=0;           //Начальный адрес регистра
//            SBUFtx[3]=0;
//            Temp2=Quant_Reg;       //Количество регистров   Quant_Reg
//            SBUFtx[4]=Temp2/256;    //старший байт затем младший
//            SBUFtx[5]=Temp2%256;
//            i2=6;
//          }
//            //Ответ функции 0х10 при наличии ошибки Exc_code_MB
//          if((Funk_Mod==0x10)&&(N_ADR_Reg==0)&&(Err_MB))
//          { SBUFtx[1]=0x90;                             //Наличие ошибки
//            SBUFtx[2]=Exc_code_MB;            //Значение кода ошибки Exc_code_MB
//            i2=3;
//          }
//    //==//==//==//==//==Конец подготовки ответа по функции 0x10 ==//==//==//==//кон
//
//    //==//==//==//==//==Подготовка ответа по функции 0x06 ==//==//==//==//нач
//         //Ответ функции 0х06         //нет ошибки Err_MB
//         if((Funk_Mod==0x06)&&(!(Err_MB)))
//         {   SBUFtx[1]=0x06;
//             SBUFtx[2]=SBUFrx[2];
//             SBUFtx[3]=SBUFrx[3];
//             SBUFtx[4]=SBUFrx[4];
//             SBUFtx[5]=SBUFrx[5];
//             i2=6;
//         }
//        //наличие ошибки Err_MB
//         if(Err_MB)
//         { //Ошибка в выборе функции
//           if(Err_MB==1)
//           {SBUFtx[1]=Funk_Mod+0x80;
//             SBUFtx[2]=0x01;
//             i2=3;
//            }
//          //Ошибка в выборе регистра
//           if(Err_MB==2)
//           {SBUFtx[1]=Funk_Mod+0x80;
//            SBUFtx[2]=N_ADR_Reg/256;SBUFtx[3]=N_ADR_Reg%256;
//            i2=4;
//            }
//         }
//
//         // if((Funk_Mod==0x06)&&(N_ADR_Reg==0)&&(Err_MB))
//         // {
//         //   SBUFtx[1]=0x86;
//         //   SBUFtx[2]=Exc_code_MB; //Значение кода ошибки Exc_code_MB
//         //    i2=3;
//         // }
//
//        }
//
//       //Станция является Мастером
//      //if(SL_Master)
//      // { //Формирование запроса для СМИ2 АДР 16 (10Н)
//      //   /*
//      //   Формирование запроса СМИ2 всего 13 байт
//       //   №бит	0    1	  2   3   4	5   6	7    8	  9    10   11	 12
//       //   Наим	АДР  Функ Рег ... Порт  ... Кол.байт Циф1 Циф2 Циф3 Циф4 CRC	CRC
//       //   Знач	10   10	  00   21  00	02	04   F2	  FC	F3  60
//       //  */
//       //  SBUFtx[0]=0x10;
//       //  SBUFtx[1]=0x10;   //Функция =10H
//       //  SBUFtx[2]=0x00;     //Рег нач =00H
//       //  SBUFtx[3]=0x21;     //Рег кон =21H
//       //  SBUFtx[4]=0x00;     //Порт нач =00H
//       //  SBUFtx[5]=0x02;     //Порт кон =02H
//       //  SBUFtx[6]=0x04;     //Кол. байт в портрете =02H
//       //  //Temp=IndArray [0]; //значение тока фазы А
//       //  Temp=3031;  //Debug
//       //   //Point4=1;          //задаем положение "," для 1-го знака после запятой
//       //  i2=Temp/1000;   //старшая цифра
//       //  if(!(i2))SBUFtx[7]=0; //старшая цифра =0 и ее "Портрет" это " "(пробел)
//       //   else SBUFtx[7]=portr[i2]; //старшая цифра !=0, перевести ее в "Портрет"
//       //  //также найти следующую цифру ...
//       //  Temp=Temp%1000;i2=Temp/100;
//       //  if((!(i2))&&(!(SBUFtx[7])))SBUFtx[8]=0; //если старшие цифры =0, то это пробелы
//       //   else SBUFtx[8]=portr[i2];
//       //  if(Point4==2)SBUFtx[9]=SBUFtx[10]+1;//Показать "," на портрете цифры
//       //  Temp=Temp%100;i2=Temp/10;
//       //  if(!(Point4))
//       //    {if((!(i2))&&(!(SBUFtx[7]))&&(!(SBUFtx[8])))SBUFtx[9]=0;
//       //     else SBUFtx[10]=portr[i2];}
//       //   else{if(Point4==2)SBUFtx[10]=portr[i2];
//       //  if(Point4==1)SBUFtx[10]=portr[i2]+1;}
//       //  i2=Temp%10;SBUFtx[10]=portr[i2];
//       //  //
//       //
//       //  i2=11;
//       //}
//         //подготовка к передаче
//                  //==//==//==//==//==Подготовка ответа по функции 110 ==//==//==//==//кон
//        P3OUT|=0x80;
//        K5|=1;P3SEL=0x30;                     //подготовка к передаче
//        K14=0; //?????
//        Temp2=CRC_16((unsigned char*)&SBUFtx[0],i2);    //KC контрольная сумма
//        SBUFtx[i2]=Temp2%256;SBUFtx[i2+1]=Temp2/256;i2=i2+2;//младший байт KC затем старший
//        i3=0;TXBUF0=SBUFtx[i3]; ME1|=UTXE0;IE1|=UTXIE0;      //разрешение прерывания по передаче передача адреса
//     }
//   }
// }
//    //сообщение обработано
//
//    if (MeasureControl) return;
//    CommonStatus&=(~0x80);
//       ADC12CTL0|=ADC12SC;
//}
//
//// The interrupt handler from ADС12
//// interrupt[ADC_VECTOR] void ADC12ISR (void) //WAS_4
//#pragma vector = ADC_VECTOR                   //WAS_4_1
//__interrupt void ADC12ISR (void)              //WAS_4
//{  IndArray [4] = ADC12MEM7;     // Запись результ измерений сопротивл изоляции
//   IndArray [5] = ADC12MEM4;     // Запись результ измерений сопротивл нижн уровня //НУ
//   IndArray [6] = ADC12MEM5;     // Запись результ измерений сопротивл верх уровня //ВУ
//   IndArray [7] = ADC12MEM6;     // Запись результ измерений сопротивл авар уровня /СХ
//  //WAS_NSZ1 нач.
//  //WAS_NSZ1 нач.
//   //Усреднение
//  cntTA4++;if(cntTA4>=5)
//  {Indarr_naysum_3+=ADC12MEM3; // Автомат,Ручное
//   Indarr_naysum_4+=ADC12MEM4; //НУ
//   Indarr_naysum_5+=ADC12MEM5; //ВУ
//   Indarr_naysum_6+=ADC12MEM6; //СХ или Мигание
//   if(cntTA0==(Period-1))
//      {// Запись результата измерений
//       IndArray[3]=Indarr_naysum_3/(cntTA4-4); // Автомат,Ручное
//       IndArray[5]=Indarr_naysum_4/(cntTA4-4); // НУ
//       IndArray[6]=Indarr_naysum_5/(cntTA4-4); // ВУ
//       IndArray[7]=Indarr_naysum_6/(cntTA4-4); // СХ или Мигание
//      }
//  }
//   CommonStatus=CommonStatus&0xFD;
//   CommonStatus|=0x80; return;
//}
//   // Обработчик прерывания по передаче UART (tx)
//   #pragma vector=USART0TX_VECTOR
// __interrupt void usart0_tx (void)
// {unsigned int i1;char i;
// i3++;if(i3==i2){TXBUF0=SBUFtx[i2];IE1&=~UTXIE0;i1=0;i=1;
// while (!(IFG1 & UTXIFG0)){i1++;if((i1>=440)&&(i)){ME1&=~UTXE0;P3OUT&=~0x80;i=0;}}
// P3SEL=0x20;K5&=(~1);ME1 |=URXE0;IE1 |=URXIE0;return;}
// TXBUF0=SBUFtx[i3];}
//
//   // Обработчик прерывания по приёму UART   ((rx)
//   #pragma vector=USART0RX_VECTOR
// __interrupt void usart0_rx (void)
//{ l2=2;
// if(cntTA3>=6)i1=0;else i1++;
// SBUFrx[i1]=RXBUF0;cntTA3=0;
// //Корректировка для приема звпросов по стандартам МБ
// // ранее работающая часть будет заменена
// //SBUFrx[1]==105)l2=ColByt_F105;
// //if(SBUFrx[1]==106)l2=ColByt_F106;
// //if(SBUFrx[1]==110)l2=ColByt_F110;
// //Переменная l2 это число байт в принимаемого запроса МБ.
// //Она рассчитывается по количеству байт передаваемой информации.
// //Для функции 0x03 значение l2 равно 8 байт.
// //Для функции 0x10 в байте SBUFrx[4] передается количество байт, которые
// // могут изменяться. К упомянутым передаваемым байтам информации добавляются
//  //служебные байты, которых имеется 9
// if((!(SL_Master))&&(i1))
//  { if(SBUFrx[0]==ADR1){
//    if(SBUFrx[1]==0x03)l2=8;
//    if(SBUFrx[1]==0x06)l2=8;
//    if(SBUFrx[1]==0x10)l2=SBUFrx[6]+9;
//    }
//  }
// //количество принимаемых байт от СМИ2 SBUFrx0
// if((SL_Master)&&((SBUFrx[1]!=0x10)||(SBUFrx[1]!=0x3)))l2=8; //количество принимаемых байт от СМИ2 SBUFrx0
//
// if(((i1+1)>=l2)&&(((!(SL_Master))&&(SBUFrx[0]==ADR1))||
//    ((SL_Master)&&(SBUFrx[0]==ADR_SMI2))))
// {IE1&=~URXIE0;ME1&=~URXE0;K5|=1;
//  if(SL_Master){Quer_MB=1;SBUFrx0=SBUFrx[0];SBUFrx[0]=0;}
// } //если ДА -прием закончен, то запрет приема и по K5 разрешить передачу
// if(i1>28) i1=0;return;
//}
//
////Подсчет контрольной суммы
// unsigned int CRC_16(unsigned char *Buffer,unsigned int length)//length
//  {unsigned int i,j,bit,Temp,CRC;
//  CRC=0xFFFF;
//  for(i=0;i<length;i++)
//  {Temp=(unsigned char)*Buffer++;
//    CRC^=Temp;
//    for (j=0;j<8;j++)
//   {bit=CRC&0x0001;CRC>>=1;
//   if(bit)CRC^=0xA001;}}
//  //WAS_нач
//  //  asm ( "mov SP,&SP1");
//  //  dSP=1023-SP1 ;
//  //  if(dSP>dSP_p)dSP_p=dSP;
//  //WAS_кон
//   /*K7=CRC;*/return(CRC);}
//
//void Init (void)      // Функция начальной инициалицации устрйства
//{    cntTA0=0;
//     TACTL = TACLR;                  // Очищаем таймер
//     MeasureControl=1;//Kz6=0;     // Запрещаем  запуск АЦП в прерывании таймера
//    // Инициализация таймера A3
//    //Таймер отсчитывает интервалы до 200 ms и генерирует прерывания каждую ms
//    CCR0 = 32;
//    // запускаем тймер с источником сигнала от ACLK, без деления,
//   // в режиме UP-mode, c разрешением прерывания
//    TACTL = TASSEL_1 + ID_0 +  MC_1 ;
//   CCTL0 = CCIE;
//
//  // Предварительная задержка при подаче питания
//   while(cntTA0<20){;}
//
//  //  All not involved pins of ports - out, 0 on an exit.
//  P3OUT = 0x00;
//  P4OUT = 0x03;   // Включаем реле ALARM
//  // Порт 5 - порт вывода инфо на дисплей
//  P5OUT = 0x00;     // На выходы порта нули
////  cntTA2=PCx=K1=K1_1=K2=K3=K4=Kz7=0;K8=K9=0;K5=0;Kz2=TimeCXNasos=0;
//#ifdef DiffZasch
//  DiffZerro=DiffZerro2;
//#endif
////  TimeStartNasos=TimePuskStop=0;//CommonStatus=0;  // Обнуляем таймера и служебный байт
//  MeasureControl=0;LevelStatus=1;
//#ifndef TK112M
//  LevelStatus_=0x07;
//#else
//  LevelStatus_=0x03;
//#endif
//#ifdef ZaschTV
//  LevelStatus_=0x0F;
//#endif
//  //Подсчитатья CRC массива arr[]
//  Temp=CRC_16((unsigned char*)&arr[0],(2*(CRC1-1)));
//  //Подсчитанная CRC массива arr[]совпалает записанной в этом массиве - ?
//  if(Temp==arr[CRC1]) goto In1; //ДА, норма
//   else  //НЕТ
//   { write_Flashw (0,0); //Перезаписать массив arr1[] в arr[]
//     //Подсчитать CRC массива arr[] после перезаписи
//    Temp=CRC_16((unsigned char*)&arr[0],(2*(CRC1-1)));
//     //После перезаписи Подсчитанная CRC массива arr[]совпалает записанной
//    if(Temp==arr[CRC1]) goto In1;//ДА, норма
//     else {KTZ=11;return;}  //ДА, Авария
//   }
//
//
// In1:
//   //Заполняем ключ Мастера SL_Master нач
//   //Адрес Станции равен 1 -  ?
//   if(arr[1]==1)SL_Master=1; //ДА, Станция является Мастером
//    else SL_Master=0;//НЕТ, Станция является Подчиненным
//          //Заполняем ключ Мастера SL_Master кон
//   // Инициализируем Flash segment указатель
//  pword1 = (unsigned int *)(Flash_SegA + 2*TK_A);
//  TKA=*pword1++;Kb2=*pword1++;
//
//  Kz8=*pword1++;
//  //Переписать аварию  из Flash в KTZ
//  KTZ=arr[Tkz];
//  if(Kz8&4)KTZ=0; //при условии (Kz8&4) ее сбросить
//  //K10=*pword1++;
//  //K10=0; //WAS ВРЕМЕННО!!!
//  K10= arr[Contr3];
//  Kb3= arr[Contr4];
//   CommonStatus=0xF3;
//   //разрешение Самозапуска нач
//  if((TKA)&&(Kb2&1)){CommonStatus|=0x0C;TimeStart=0;  //Kb2&2 -> Kb2&1 WAS
//                     if(TKA==1) Pusk_On=1;           // 09 05 2018
//                     if(TKA==2) TaskMB=1;           // 09 05 2018
//                     if(TKA>2)  {TaskMB=1;Kb2_1=1;} // 09 05 2018
//                    }
//    //разрешение Самозапуска кон
//  //Из Flash переписать значения токов Ia,Ib и Ia, записанных в нее
//  //во время перезапуска системы, в переменные IndArray[0],IndArray[1] и
//  // IndArray[0],
//  if(KTZ)
//   {IndArray[0]=arr[IndArr0];IndArray[1]=arr[IndArr1];
//    IndArray[2]=arr[IndArr2];//K5=2;
//    if(!(P2IN&4))               //????
//     {KTZ=0;K5=4;               //????
//      write_Flashw (KTZ,Tkz);  //(!(Kz8&4))
//     }
//   }
//  Cr_Tpr=0;
//  if(KTZ)K4=4; //Для возможности работы Модбас
// }
//
//void LOOPInit (void)      // Функция циклической инициалицации устрйства
//{if((P2IN&4)&&(K5==4)){INDMODE=0;K5=0;}
//// if((!(P2IN&0x02))&&(KTZ)){MeasureControl=KTZ=0;write_Flashw (KTZ,Tkz);}
//  //  All not involved pins of ports - out, 0 on an exit.
//  P1OUT = 0x00;
//  P1IES = 0;         // Флаг прерывания выставляется по фронту
//  P1IE  = 0x80;      // запрешаем прерывание по Р1.7                //80   20
//  P1SEL = 0x00;      // Выбираем порт без альтернативных функций
//  P1DIR = 0x7F;//5F  // Порт работает как выход      0x7F           //7F   5F
//
//  P3DIR = 0x9F;      // Два вывода используем как входы (P3.5-приём UART,
//  P3OUT|=0x10;                   //P3.6 разрешение - запрет калибровок)
//  P3SEL|=0x20;       // Pins P3.4,5 - in a USART0 mode(TX,RX)
//
//  // реле ALARM и управляющее реле
//  P4SEL=0x00;     // Выбираем порт без альтернативных функций
//  P4DIR = 0xFF;
//
//   // Порт 2 - порт подключаемый к внешним и внутренним кнопкам
//  P2SEL= 0x20;    // P2.5 выход для внешнего резистора тактового генератора процессора
//  P2DIR = 0x00;   // Часть выводов порта работает как выход
//  P2IES = 0;      // Флаг прерывания выставляется по фронту
//  P2IE = 0x40;    // Разрешаем прерывание по Р2.6
//  P2OUT = 0x00;   // На выходы порта нули
//  Kz6=7;
//  // Порт 5 - порт вывода инфо на дисплей
//  P5SEL=0x00;      // Выбираем порт без альтернативных функций
//  P5DIR = 0xFF;     // Порт работает как выход
//
//  // Инициализация тайкера A3
//        //Таймер отсчитывает интервалы до 200 ms и генерирует прерывания каждую ms
//  CCR0 = 32;                     // 32,768/32 = 1024 Hz (1 ms).
//  // запускаем тймер с источником сигнала от ACLK, без деления,
//   // в режиме UP-mode, c разрешением прерывания
//  TACTL = TASSEL_1 + ID_0 +  MC_1 ;
//  CCTL0 = CCIE;
//
//  // Инициализация АЦП и каналов измерения
//  P6OUT = 0x00;
//  P6DIR = 0x00;   // Используем 8 входов АЦП
//                  // A0 - Измерение тока фазы А
//                  // A1 - Измерение тока фазы B
//                  // A2 - Cумма токов фаз А и Б
//                  // A3 - Вход дифференциальной защиты
//                  // A4 - Измерение нижнего уровня
//                  // A5 - Измерение верхнего уровня
//                  // A6 - Измерение сухого хода
//                  // А7 - Измерение сопротивления изоляции
//  P6SEL = 0x0FF;                        // Включение каналов A0,A1,A2,A3,А4,A5,А6,A7
//
//  ADC12CTL0 = ADC12ON+REFON+REF2_5V+MSC+SHT0_6+SHT1_2;     //_4,_4
//                                         // Включение ADC12  и опорного источника напряжения Uоп = 2.5в,
//                                         // после окончания выбоки одного канала приступает к выборке следующего,
//                                         // время выборки   1/5MГц * 192 = 38.4 мкс. Для  8-ми каналов: 38.4*8 = 44.8 мкс.
//                                         // Минимально допустимое время выборки при Rисточника=1kOm - 1.1 мкс
//                                         //                                     при Rисточника=10kOm - 4.33 мкс
//  ADC12CTL1 = SHP+CONSEQ_1+ADC12SSEL_2 ; // Включение таймера выборки,
//                                         // однократная последовательность,тактируется от MCLK //{УЖЕ НЕ ТАКТИРУЕТСЯ Тактируется от внутреннего генератора с частотой от 3.7 до 6.3 MГц (средняя 5 МГц)}
//  ADC12MCTL0 = SREF_1+INCH_0;            // Канал A0  VREF+ = 1.5v,  Измерение тока фазы А
//  ADC12MCTL1 = SREF_1+INCH_1;            // Канал A1  VREF+ = 1.5v,  Измерение тока фазы B
//  ADC12MCTL2 = SREF_1+INCH_2;            // Канал A2  VREF+ = 1.5v, Вход суммы токов фаз А и В.
//  ADC12MCTL3 = SREF_1+INCH_3;            // Канал A3  VREF+ = 1.5v, Вход дифференциальной защиты
//  ADC12MCTL4 = SREF_1+INCH_4;            // Канал A4  VREF+ = 1.5v, Измерение нижнего уровня
//  ADC12MCTL5 = SREF_1+INCH_5;            // Канал A5  VREF+ = 1.5v, Измерение верхнего уровня
//  ADC12MCTL6 = SREF_1+INCH_6;            // Канал A6, VREF+ = 1.5v, Измерение сухого хода
//  ADC12MCTL7 = SREF_1+INCH_7+EOS;        // Канал А7, VREF+ = 1.5v, конец последовательности, Измерение сопротивления изоляции
//  ADC12IE = 0x80;                        // Разрешение прерывания ADC12IFG.7.
//                                         // Для сброса флага прерывания ADC12IFG.х необходимо считать регистор ADC12MEMx
//                                         // или сделать это программно
//  ADC12CTL0 |= ENC;                      // Разрешение преобразования
//
//  //Процессор тактируется от RC генератора с внешним резистором
//  BCSCTL2=DCOR;
//  BCSCTL1=BCSCTL1|(RSEL2+RSEL1);            // Повышаем частоту работы процессора
//  DCOCTL|= (DCO2+DCO1+DCO0);
//
//   // инициализация UART
////  #ifdef EnableRS232
//  if((!(K5&1))||(!(P3IN&0x80))){
//   if(K4>=4)P3SEL=0x20;P3OUT&=~0x80;//20
//   UCTL0|= CHAR; UCTL0&=0x18;          // 8 bits
//   UTCTL0 = SSEL0;                     // Clocking UCLK = ACLK
//   UBR10 = 0x00;                       //
//ME1 |= URXE0;// + UTXE0;               // Enable USART0 RXD and TXD
//   IE1 |= URXIE0;// +UTXIE0;           // Resolution of interruption USART0 RX
//    UBR00=0x03;UMCTL0=0x4a;}
//
// // pword1=(unsigned int*) (Flash_SegA + 2*Adress);//
// // ADR=*pword1%256;
//    ADR1= arr[1]&0x000F; //WAS -сетевой адрес подчиненного
//   pword1=(unsigned int*)(Flash_SegA + 2*PowerMotor);
//  Tiporazmer=*pword1;
//  pword1 = (unsigned int *)(Flash_SegA + 2*TimeCX);
//  TimeCXN=*pword1++;
//  Kz5=*pword1++; //уставка по  Т и Влажности
//  Kz3=*pword1++; //UstZach->kol_zapkol_zap, Кол.запуск за 4 мин
//  IsolUst=*pword1++; //уставка по изоляции или задержка по П. Пуску
//  Ppusk1=arr[PP_Isol];  //Заполнить флаг выбора лоя Плавного Пуска
//  if(Ppusk1)IsolUst=arr[Ust_PP]; //Подмена Уставкой для Плавного пуска
//  LevelUst=*pword1++; //Порог срабатыв. датчиков уровня
//  TKA=*pword1++;     //Режимы управления Р=1(руч., arr[23]
//  Kb2=*pword1++;     //ранее UstZach3:(Kb2&1) - однофазный двигат.
//                     //- (Kb2&2)- самозапуск
//  Kz8=*pword1;       //Вкл мотор и др.,arr[25]
//  Samo_zp= arr[samozap]; //WAS самозапуск
//  Faz=  arr[kol_faz];  //WAS кол. фаз; =3 -однофазный
//  //ВРЕМЕННО!!! Восстановить Kb2 нач.
//  if(Samo_zp)Kb2= Kb2 | 0x02;
//            else Kb2= Kb2 & 0xFD;
//  if(Faz==3)Kb2= Kb2 | 0x01; // однофазный
//            else Kb2= Kb2 & 0xFE;
//  //ВРЕМЕННО!!! Восстановить Kb2 .. кон
//    if(arr[1]==1)SL_Master=1; //ДА, Станция является Мастером
//    else SL_Master=0;//НЕТ, Станция является Подчиненным
//          //Заполняем ключ Мастера SL_Master кон
//}
//
////**********************************************************************************************
////**********************************************************************************************
////    фУНКЦИИ ОПРЕДЕЛЕНИЯ ДИАПАЗОНА ИЗМЕРЯЕМОГО ТОКА И РАСЧЁТА ЗНАЧЕНИЙ ТОКОВ
//// Таблица диапaзонов измеряемых токов
//# ifdef Dt_nov
// const unsigned int CurrentDiap[8]={3690,369,1932,417,/*1060*/745};//417/660(Xмельн)) (300A_130ед)1014/745
//// const unsigned int CurrentDiap[8]={1163,235,1035,240,405};//4R3 1035
//# else
//// const unsigned int CurrentDiap[8]={1148,232,1021,396,396};//307(374,1080/500A),1243,(3550,680(Xмельн))
//                                               //493,1308,1024   ,1148,237,1021,307(297),396
//// const unsigned int CurrentDiap[8]={1280,260,1243,374,523};//(374,1080/500A),1243,(3550,680(Xмельн))
// const unsigned int CurrentDiap[4]={1160,233,1029,398};//3R9  1029/2            309
//#endif
//
// char Diapozon;//,Tiporazmer;  // Переменная хранящая номер диапазона (или индекс в таблице  CurrentDiap[8])
//
//// Функция определения диапазона токового измерения
//// включает соответствующий коэффициент усиления
//// и определяет индекс для таблицы  CurrentDiap[8] (передаёт его через Diapozon)
//void DefineDiap (void)
//{  // Считываем номер кольца
//   //  pword1=(unsigned int*)(Flash_SegA + 2*PowerMotor);
//   //  Tiporazmer=*pword1;
// #ifndef TK
//            switch(Tiporazmer)
//             {case 0:  UstImaxDiap=1700;Diapozon=0;break;
//              case 1:  UstImaxDiap=305;Diapozon=1;break;   // 2400 260
//              case 2:  UstImaxDiap=550;Diapozon=2;break;   //4800
//              case 3:  UstImaxDiap=850;Diapozon=2;break;   //4800 //750//850//1000
//              case 4:  UstImaxDiap=100;Diapozon=3;break;   //4800
//              case 5:  UstImaxDiap=220;Diapozon=3;break;   //4800
//              case 6:  UstImaxDiap=360;Diapozon=3;break;   //4800
//              default: UstImaxDiap=600;Diapozon=4;         //9600
//             }
//  #else
//    Diapozon=Tiporazmer-1;
//     switch(Tiporazmer)
//      {case 1: UstImaxDiap=1700;/*Diapozon=0;*/break;
//       case 2: UstImaxDiap=305;/*Diapozon=1;*/break;
//       case 3: UstImaxDiap=960;/*Diapozon=2;*/break;
//       case 4: UstImaxDiap=360;/*Diapozon=3;*/break;
//       default:UstImaxDiap=600;//Diapozon=4;//break;  // 500
//       }
//  #endif
//  if(!(Diapozon)) K6=16;  else K6=32;
//    if((K9)&&(K9!=INDMODE+1))
//          { switch(K9)
//             {//case  1:write_Flashw (Value1,TK_A);break;
//              case  2:write_Flashw (Value1,X2A1);break;
//              case  3:write_Flashw (Value1,X2B1);break;
//              case  4:write_Flashw (Value1,X2C1);break;
//              case  5:write_Flashw (Value1,X2Diff);break;
//               //case 12:write_Flashw (Value1,IsolUst1);break;
//               //case 13:if(!(K10))write_Flashw (Value1,UstZach);
//               //   else write_Flashw (Value1,UstZach2);break;
//              case 15:write_Flashw (Value1,UstZach1);break;
//             }
//              //case 16:write_Flashw (Value1,LevelUst1);break;}
//            K9=0;
//          }
// }
//
//// Функция расчёта выходного параметра по 2 калибровочным точкам (x1,0) и (x2,y2)
//// Формула y=((y2-0)*(x-x1))/(x2-x1) + 0
//signed int MakeConvert (signed int Input,unsigned int Offset)
//{ signed int x1;
//   signed long Temp;
//   if(Offset==X1Diff) Temp=Y2diff;
//   else Temp=(long)CurrentDiap[Diapozon];     // Считываем номинальный ток соответствующий диапазону - y1
//   pword1=(unsigned int*)(Flash_SegA + 2*Offset);
//   x1=(*pword1++);
//   Input-=x1;                            //(x-x1)
////   Temp=(long)CurrentDiap[Diapozon];     // Считываем номинальный ток соответствующий диапазону - y1
//   Temp=Temp*Input;                      //y2*(x-x1)
//   if((K9>1)&&(K9<6))Temp=Temp/(Value1-x1);
//   else Temp=Temp/((*pword1)-x1);             //(y2*(x-x1))/(x2-x1)
////   Temp=Temp*Input;                      //y2*(x-x1)
////   Temp=Temp/((*pword1)-x1);             //(y2*(x-x1))/(x2-x1)
//   if (Temp<5)Temp=0;
//   return Temp;
//}
//
//// Функция перерасчёта уставки диффзащиты в инженерных единицах в биты
//// по 2 калибровочным точкам (x1,y1) и (x2,y2),
//// Формула x=(y*(x2-x1))/Y2diff + x1
///* signed int CalcInp (void)
//{ signed int x;
//  signed long Temp;
//  pword1=(unsigned int*) (Flash_SegA + 2*X1Diff);
//        // Считываем из Flash уставку X1
//  x=*pword1++;
//  Temp=x;
//  Temp=*pword1++ -Temp;    // Считываем из Flash X2
//                  // Считываем из Flash уставку Y
//  Temp=(*pword1*Temp)/Y2diff+x;
//  return Temp/2;
//} */
// signed int CalcInp (void)
//{ signed int x;
//  signed long Temp;
//  pword1=(unsigned int*) (Flash_SegA + 2*X1Diff);
//        // Считываем из Flash уставку x
//  x=*pword1;
//  Temp=(signed long)x;
//  pword1++;
//  Temp=*pword1-Temp;    // Считываем из Flash X1
//                  // Считываем из Flash уставку Y
//  pword1=(unsigned int*) (Flash_SegA + 2*IdiffMax);
//  Temp=Temp*((signed long)*pword1);
//  Temp/=Y2diff;
//  Temp+=x;
//  return Temp/2;
//}
//
////*****************************************************************************************
//
//// Функция екпонентциального фильтра
// void EXP ( signed int Input, signed int *Output, signed int *Remainder,unsigned int Tau)
// { Tau = (1000/Period)*Tau;     //Получившееся Тau не может быть больше 32767
//   Input = Input - (*Output);
//   *Remainder = *Remainder + Input%(signed int)Tau;
//   *Output =*Output + Input/(signed int)Tau;
//   if(*Remainder >=  0 ){ if (*Remainder >=  Tau ) {*Output=*Output+1;*Remainder=*Remainder-Tau;}
//                        }
//   else { if (-(*Remainder) >= Tau ) {*Output=*Output-1;*Remainder=*Remainder+Tau;}
//        }
//  if (*Output<0) *Output=0;
// }
//
//// Переменные для измерения токов на 3-х фазах и дифф. тока
// unsigned int PhaseAMax,PhaseBMax,PhaseCMax,DiffMax;  // Найденные максимальные значения
// unsigned int PhaseAMin,PhaseBMin,PhaseCMin,DiffMin;  // Найденные минимальные значения
// unsigned int PhaseAMid=2000,PhaseBMid=2000,PhaseCMid=2000;//DiffMid;  // Найденные значения нуля
// unsigned int PhaseAQ,PhaseBQ,PhaseCQ;                // Мгновенные значения токов
// unsigned int Imax,Imin;                              // Неотфильтрованные значения максимального и минимального токов
//
//  // Остатки для фильтров вывода информации значений токов на индикатор
//unsigned int RemAInd;  // Фаза А
//unsigned int RemBInd;  // Фаза С
//unsigned int RemCInd;  // Фаза В
//// Выходы фильтров вывода информации значений токов на индикатор
//unsigned int AInd;  // Фаза А
//unsigned int BInd;  // Фаза С
//unsigned int CInd;  // Фаза В
//
//# define NumPeriod  4 // Количество периодов за которые производим измерения
//
// // Функция измерения на протяжении 4-х периодов
//void MeasureAndCalcCurrent (void)
//{  char i,j;
//   unsigned long PhaseAsum=0,PhaseBsum=0,PhaseCsum=0;
//    Diffsum=0; //WAS_5 уьрал unsigned long т.к. двойное объявление
//   PerNetCount=NumSamples=j=0;                                        // Обнуляем счётчик периодов
//   // Ожидаем начала нового периода
//   while ((!j)&&(!PerNetCount)) {
//                         #ifdef EnableRS232
//                          Answer();                     // Обмен по интерфейсу
//                          #endif
//                          if (cntTA0 >22) {cntTA0=0;j=1;P1IE = 0x0;}//CCTL0=0;    //reset WDT, ecли нет перехода через ноль
//                         }
//
//   while (CommonStatus&2){;}                     // Ожидаем окончания обработки прерывания АЦП
//   MeasureControl=1;                             // Запрещаем запуск АЦП по таймеру 1 ms
//   ADC12IE = 0x00;                               // запрещаем прерывание по AЦП
//   i=PerNetCount;
//
//while  (((!j)&&(i<(NumPeriod+1)))||(j&&(cntTA0<81)))
//  {   PhaseAMax=PhaseBMax=PhaseCMax=DiffMax=0;      // Обнуляем максимумы
//      PhaseAMin=PhaseBMin=PhaseCMin=DiffMin=4096;   // Завышаем минимумы
//   // Производим измерение тока в течение 1-го периода
//   while (((!j)&&(i==PerNetCount))||(j&&(cntTA0<81)))
//   {  ADC12CTL0|=ADC12SC;                                          // Запуск однократной последовательности преобразований
//      while (ADC12CTL1 & ADC12BUSY){;}                            // ожидаем окончания преобразования
//      if( PhaseAMax < ADC12MEM0)PhaseAMax=ADC12MEM0;             // Поиск максимальных и минимальных значений на фазе А
//      if( PhaseAMin > ADC12MEM0)PhaseAMin=ADC12MEM0;
//      if( PhaseBMax < ADC12MEM1)PhaseBMax=ADC12MEM1;             // Поиск максимальных и минимальных значений на фазе B
//      if( PhaseBMin > ADC12MEM1)PhaseBMin=ADC12MEM1;
//      if( PhaseCMax < ADC12MEM2)PhaseCMax=ADC12MEM2;             // Поиск максимальных и минимальных значений на фазе C
//      if( PhaseCMin > ADC12MEM2)PhaseCMin=ADC12MEM2;
//      if( DiffMax < ADC12MEM3)DiffMax=ADC12MEM3;             // Поиск максимальных и минимальных значений на фазе А
//      if( DiffMin > ADC12MEM3)DiffMin=ADC12MEM3;
//
//      Temp=(char)ADC12MEM7;              // Cбрасываем флаг окончания преобразования АЦП
//      CommonStatus=CommonStatus&0xFD;
//      // Суммируем средне квадратичное по каждой фазе
//      if( ADC12MEM0 > PhaseAMid) PhaseAQ = ADC12MEM0 - PhaseAMid;
//      else PhaseAQ = PhaseAMid - ADC12MEM0;
//      PhaseAsum+=((unsigned long)PhaseAQ *(unsigned long)PhaseAQ);
//      if( ADC12MEM1 > PhaseBMid) PhaseBQ = ADC12MEM1 - PhaseBMid;
//      else PhaseBQ = PhaseBMid - ADC12MEM1;
//      PhaseBsum+=((unsigned long)PhaseBQ *(unsigned long)PhaseBQ);
//
//      if( ADC12MEM2 > PhaseCMid) PhaseCQ = ADC12MEM2 - PhaseCMid;
//      else PhaseCQ = PhaseCMid - ADC12MEM2;
//      PhaseCsum+=((unsigned long)PhaseCQ *(unsigned long)PhaseCQ);
//
//      NumSamples++;
//      if (cntTA0 > (40+NumPeriod*25)) {P1IE = 0x0;j=1;}//CCTL0=0; // Reset WDT, ecли нет перехода через ноль
//
//       #ifdef EnableRS232
//              Answer();
//       #endif
//              continue;
//   }
//     i=PerNetCount;
//     PhaseAMid =(PhaseAMax+PhaseAMin)/2;      // Вычисляем ноли фаз
//     PhaseBMid =(PhaseBMax+PhaseBMin)/2;
//     PhaseCMid =(PhaseCMax+PhaseCMin)/2;
//
//  #ifdef DiffZasch
//     DiffZerro1=(DiffMax+DiffMin)/2;            // Вычисляем ноль дифзащиты;
//     if (DiffZerro1>(DiffZerro+2)) DiffZerro++;
//     if ((DiffZerro-2)>DiffZerro1) DiffZerro--;
//    // Суммирюем значения по диффзащите
//     Diffsum+=(DiffMax-DiffMin);
//  #endif
//  }
//     ADC12IE = 0x80;                               // Разрешение прерывания ADC12IFG.7.
//     MeasureControl=0;
//     // Вычисляем среднее
//     PhaseAsum=PhaseAsum/NumSamples;
//     PhaseBsum=PhaseBsum/NumSamples;
//     PhaseCsum=PhaseCsum/NumSamples;
//
//    // Извлекаем корни
//     PhaseAMin=PhaseAMax=(unsigned int)sqrt(PhaseAsum);
//     PhaseBMin=PhaseBMax=(unsigned int)sqrt(PhaseBsum);
//     PhaseCMin=PhaseCMax=(unsigned int)sqrt(PhaseCsum);
//
//#ifdef DiffZasch
//     DiffMid=Diffsum/NumPeriod;
//#endif
//      // Находим неотфильтрованые значения Imax, Imin
//      // Находим неотфильтрованые значения Imax, Imin
//   #ifdef EnableConvert
//      PhaseAMax = MakeConvert(PhaseAMax,X1A1); // Расчёт тока фазы А
//      PhaseBMax = MakeConvert( PhaseBMax,X1B1); // Расчёт тока фазы B
//      PhaseCMax = MakeConvert(PhaseCMax,X1C1); // Расчёт тока фазы C
//    #endif
//      if(Faz==3){PhaseBMax =PhaseCMax =0;}//WAS только для 1-но фазн.двиг. 18 05 2018
//      if (PhaseAMax>PhaseBMax) {Imax=PhaseAMax;Imin=PhaseBMax;}
//      else {Imax=PhaseBMax;Imin=PhaseAMax;}
//      if (PhaseCMax > Imax)  {Imax= PhaseCMax;}
//      if (PhaseCMax < Imin)  {Imin= PhaseCMax;}
//
//  // Если время после пуска двигателя меньше TimePuskStopMax/2, то не фильтруем показания индикатора
//    if(TimePuskStop<(TimePuskStopMax/2)) {AInd=PhaseAMin;BInd=PhaseBMin;CInd=PhaseCMin;}
//    else
//    { //Фильтруем позакания индикатора для тока
//      // Определяем для фазы А
//      pword1= (unsigned int*)&AInd;
//      pword2= (unsigned int*)&RemAInd;
//      EXP (PhaseAMin, (signed int*)pword1,(signed int*)pword2,TauIndI) ;
//      // Определяем для фазы В
//      pword1= (unsigned int*)&BInd;
//      pword2= (unsigned int*)&RemBInd;
//      EXP (PhaseBMin, (signed int*)pword1,(signed int*)pword2,TauIndI) ;
//      // Определяем для фазы С
//      pword1= (unsigned int*)&CInd;
//      pword2= (unsigned int*)&RemCInd;
//      EXP (PhaseCMin, (signed int*)pword1,(signed int*)pword2,TauIndI) ;
//     }
//  // Вывод на индикатор значений тока
//
//  #ifdef EnableConvert
//         IndArray [0] = MakeConvert(AInd,X1A1); // Расчёт тока фазы А
//         IndArray [1] = MakeConvert(BInd,X1B1); // Расчёт тока фазы B
//         IndArray [2] = MakeConvert(CInd,X1C1); // Расчёт тока фазы C        if ((!(P2IN&0x10))&&(!(P2IN&0x08))&&(cntTM))
//     #ifdef DiffZasch
//         IndArray [3] = MakeConvert(DiffMid,X1Diff);//Idiff
//     #endif
//  #else
//         IndArray [0] = AInd; // Расчёт тока фазы А
//         IndArray [1] = BInd; // Расчёт тока фазы B
//         IndArray [2] = CInd; // Расчёт тока фазы C
//
//     #ifdef DiffZasch
//         IndArray [3] = DiffMid; // Расчёт дифф тока
//     #endif
//  #endif
//     #ifndef DiffZasch
//         IndArray [3] = 0;
//     #endif
//     IndArray [3] = 7; //Асимметрия //ВРЕМННО!!!!
//     if(Faz==3){IndArray[1] =IndArray[2]=0;}//WAS только для 1-но фазн.двиг. 18 05 2018
//  //Коррекция тока кнопками
//    if((P2IN&0x10)&&(P2IN&0x08))cntTL=cntTM=0;
//    if (!(P3IN&0x40)){
//      if ((!(P2IN&0x10))&&(P2IN&0x08)){cntT0=cntTL=0;cntTM=1;}
//      if ((!(P2IN&0x08))&&(P2IN&0x10)){cntT0=cntTM=0;cntTL=1;}
//      if ((!(P2IN&0x10))&&(!(P2IN&0x08))&&((cntTM)||(cntTL)))
//       {cntT0++;if(cntT0>1){cntT0=0;
//  switch(INDMODE)
//     {//case 0:if(cntTM){TKA++;if(TKA>4)TKA=0;write_Flashw (TKA,TK_A);}break; //WD по v0.4
//      case 1:if(!(K9)){pword1 =(unsigned int *)(Flash_SegA + 2*X2A1);Value1=*pword1;}
//       K9=2;if(cntTM) Value1--;if(cntTL) Value1++;break;
//      case 2:if(!(K9)){pword1 =(unsigned int *)(Flash_SegA + 2*X2B1);Value1=*pword1;}
//       K9=3;if(cntTM) Value1--;if(cntTL) Value1++;break;
//      case 3:if(!(K9)){pword1 =(unsigned int *)(Flash_SegA + 2*X2C1);Value1=*pword1;}
//       K9=4;if(cntTM) Value1--;if(cntTL) Value1++;break;
//      case 4:if(!(K9)){pword1 =(unsigned int *)(Flash_SegA + 2*X2Diff);Value1=*pword1;}
//       K9=5;if(cntTM) Value1--;if(cntTL) Value1++;break;
//     //  #ifndef TK
//     // case 8:
//     //  if(cntTM){Tiporazmer++;
//     //  if(Tiporazmer>7)Tiporazmer=0;                       //>7
//     //  write_Flashw (Tiporazmer,PowerMotor);}break;
//      // #endif
//      case 11:if(!(K9))Value1=IsolUst;K9=12;if(cntTM)Value1++;if(cntTL)Value1--;break;
//      case 12:if(cntTL){Kz8++;if(Kz8>7)Kz8=0;write_Flashw (Kz8,UstZach2);}
//                      if(cntTM){Kz3++;if(Kz3>22)Kz3=5;write_Flashw (Kz3,UstZach);}break;
////      case 12:if(cntTM){if(!(K9))Value1=Kz3;K9=13;K10=0;Value1++;if(Value1>22)Value1=2;}
////            if(cntTL){if(!(K9))Value1=Kz8;K9=13;K10=1;Value1++;if(Value1>15)Value1=0;}break;
//      case 14:if(!(K9))Value1=Kz5;K9=15;if(cntTM){Value1++;}//if(Value1>50)Value1=3;}
//       if(cntTL)Value1--;if(Value1<1)Value1=1;break;
//     }
//                       }
//       }}
////    else K9=0;
//}
//
//// Функция определения выхода токов за пределы максимальных,минимальных уставок и ассиметрии
//void PhaseMaxMinAssim (void)
//{ unsigned int /*TauTEMP,*/UstImax,UstIcx;
//  long Tmp1;
// // Считываем из FLASH значение уставки по максимальному току
//    pword1 = (unsigned int *)(Flash_SegA + 2*Imax1kVt);
//    UstImax=*pword1++;
//
//  // Считываем из FLASH значение уставки по току сухого хода
//  UstIcx = *pword1++; //if(Diapozon>3) UstIcx/=10;
//  TauTEMP = *pword1;  // Определяем постянную времени уставки с учетом фильтра по индикации
//  if(Kz3<20)
//  {if(Imax>5*UstImax/4) Kz1=1;
//  if(Kz1)
//  {if(Imax<UstImax/2){Kz2++;Kz1=0;}}     // превышает некоторое значение, то считаем, что двигатель включён.
//  if(Kz2>=Kz3){KTZ=8;Kz2=K8=0;return;}
//  if(Kz2){K8++;//TimeContr1++;
//  if(K8>1200) Kz2=K8=0;}
//  }
//   if(TKA>1)
//  {// Определяем состояние двигателя
//  #ifndef EnableNasos
////  if(P4OUT&1)return;
//  if((Imax<=UstImax/K6)||(P4OUT&1)){if(CommonStatus&1){TimePuskStop=0;CommonStatus&=(~1);}return;}
//  else { if(!(CommonStatus&1)){TimePuskStop=0;CommonStatus|=1;}}   // Если ток превышает некоторое значение, то считаем, что двигатель включён.
//  #else
//  if (!(P4OUT&1))  CommonStatus|=1;;
//  if(P4OUT&1) {CommonStatus&=(~1);return;}
//  #endif
//  }
//
//  // Здесь определяем ассиметрию
////  pword1= (unsigned int*)&Assim_O;
////  pword2= (unsigned int*)&RemAssim;
////  EXP (Imax-Imin,(signed int*)pword1,(signed int*)pword2,TauIasim);
//
//// Определяем для максимальной фазы
//  pword1= (unsigned int*)&PhaseMax_O;
//  pword2= (unsigned int*)&RemPhaseMax;
//  EXP (Imax, (signed int*)pword1,(signed int*)pword2,TauTEMP) ;//
//// PhaseMax_O=PhaseCx_O=RemPhaseMax=RemPhaseCx=Assim_O=RemAssim=0; //при выключенном двигателе обнуляем значения максимальных и минимальных токов и ассиметрию
//
//// Определяем для cухого хода
//  pword1= (unsigned int*)&PhaseCx_O;
//  pword2= (unsigned int*)&RemPhaseCx;
//  EXP (Imax, (signed int*)pword1,(signed int*)pword2,TauIcx) ;//
//   if(TimePuskStop<TimePuskStopMax) return;// Если время после пуска двигателя более 10s, то проверяем защиты
//
//// Определяем для максимальной фазы
////  pword1= (unsigned int*)&PhaseMax_O;
////  pword2= (unsigned int*)&RemPhaseMax;
////  EXP (Imax, (signed int*)pword1,(signed int*)pword2,TauTEMP) ;//
//  // Здесь определяем ассиметрию
//  pword1= (unsigned int*)&Assim_O;
//  pword2= (unsigned int*)&RemAssim;
//  EXP (Imax-Imin,(signed int*)pword1,(signed int*)pword2,TauIasim);
//   if (PhaseMax_O >= UstImax)// Px++;else{Px=0;}if(Px>25) //
//   {KTZ=2;return;}
//   if((PhaseCx_O < UstIcx)&&(PhaseCx_O > (UstIcx/4))) PCx++;
//     else PCx=0;
//   if(PCx>25){KTZ=3;PCx=0;if(Kz8&1)CommonStatus|=0x10;return;}//25,2
//   //Двигатель 3-х фазный -?
//   //if(!(Kb2&1))
//   if(Faz!=3)
//   {//ДА, имеется перекос фаз -?
//     //Для индикации нв дисплее показывать наличие перекоса фаз,
//     // рассчитывая его по зависимости:
//     // Assim_O_Prz = (Assim_O/(UstImax/2))*100 %
//     // для избежения переполнения эта формула рассчит. поэтопно, см. ниже
//     Tmp1= ((Assim_O*20)/UstImax)*10;
//      Assim_O_Prz=Tmp1;
//     //Имеется перекос фаз -?
//     if(Assim_O >=(UstImax/2))
//     {KTZ=1;return;} //ДА, срабатывает защита
//   }
//   //Сюда приходим для однофазного двигателя и при этом игнорируется защита
//   //по перекосу фаз
//  // Zasch:write_Flashw (KTZ,Tkz);//if(K10&0x10){K10=~0x10;write_Flashw (KTZ,Tkz);}
//}
//
////   #ifndef TKM
//void Isolation (void) // Функция определения и защиты по сопротивлению изоляции
// { // Определяем            сопротивление изоляции
//    // if(!(KTZ==4))K8++;
//  if (TimePuskStop<TimeIsol){Isol_O=IndArray [4];RemIsol=0;return;} // Если устойство недавно включено или двигатель недавно включен-выключен,то обходим фильтр
//  if (!(Kz7)){Kz7=1;Isol_O=IsolUst+5;/*IndArray [4];*/RemIsol=0;/*IsolUst;*/} // Если устойство недавно включено или двигатель недавно включен-выключен,то обходим фильтр
//  pword1= (unsigned int*)&Isol_O;
//  pword2= (unsigned int*)&RemIsol;
//  EXP (IndArray [4], (signed int*)pword1,(signed int*)pword2,TauIzol) ;//
//   //Контроль Изоляции  двигателя -?
//  //#ifndef Ppusk
//  if(!(Ppusk1))
//   { //ДА
//    if (TimePuskStop<TimePuskStopMax/2) return; //
//    #ifndef TKM
//     if (Isol_O < IsolUst) KTZ=4;
//    #endif
//   }
//  //#else
//  else
//   //Работа с Плавным Пуском
//   if (!(P4OUT&1))
//    {if(((IsolUst>=400)&&(Isol_O > IsolUst))||
//            ((IsolUst<400)&&(Isol_O < IsolUst)))
//       {TimeTr++;if(TimeTr>8){TimeTr=0;KTZ=4;}}
//     //двигатель включен
//      if(((IsolUst>=400)&&(Isol_O > IsolUst))||
//            ((IsolUst<400)&&(Isol_O < IsolUst)))
//       {TimeTr++;if(TimeTr>4){TimeTr=0;KTZ=4;}}
//      else TimeTr=0;
//     //не испытано   нач
//     // if((Isol_O>35)&&(Isol_O <400)){g5++;if(g5>100){KTZ=4;g5=0;}}
//     // else g5=0;}
//     //не испытано   кон
//    }
//  //#endif
// }
//
//// установка принятых команд с МБ 27 11 2019
//void Command_MB (char Cmd_grup)
//{  //групповой прием команд
//  if(Cmd_grup==1)
//   {
//    RJ_Mod=(SBUFrx[7]<<8)+SBUFrx[8]; //Команда: Заданный режим работы станции
//    Task_Station=(SBUFrx[9]<<8)+SBUFrx[10]; //Задание на автоматич.работу станции
//                             //игноррируется при режиме РУЧНОЙ
//    Command_Driv=(SBUFrx[11]<<8)+SBUFrx[12];//Команда ВКЛ/ОТКЛ мотор.
//                                           //Игнорируется при
//                                          //режиме станции АВТОМАТИЧЕСКИЙ
//    Reset_Protect1=(SBUFrx[13]<<8)+SBUFrx[14]; //Сброс защиты
//    Reset_Protect2=(SBUFrx[15]<<8)+SBUFrx[16]; //Сброс ограничения сбросов защиты,счетчик=0
//     //Прием  пароля
//    Temp=(SBUFrx[17]<<8)+SBUFrx[18];
//    if(Temp==arr[29]){Parol_MB=1234;Parol_bt=1;Rec_Setp_MB=0;SetpointMB=0;}
//         //Сброс наличия пароля  кон.
//    else {Parol_MB=Temp;Parol_bt=0;}
//   }
//  if(Cmd_grup==2)
//   { Temp=(SBUFrx[4]<<8)+SBUFrx[5];
//    if(!(SBUFrx[3]))RJ_Mod=Temp; //Команда: Заданный режим работы станции
//    if(SBUFrx[3]==1)Task_Station=Temp; //Задание на автоматич.работу станции
//                             //игноррируется при режиме РУЧНОЙ
//    if(SBUFrx[3]==2) Command_Driv=Temp;//Команда ВКЛ/ОТКЛ мотор.
//                                           //Игнорируется при
//                                          //режиме станции АВТОМАТИЧЕСКИЙ
//            //Формирование флага-подмены команды Command_Driv=1для реж ДИСТ-АВТ
//            if((TKA==4)&&(Task_Station==1)&&(Command_Driv==1)&&(NU))
//              Comd_Driv_d=1;
//            //
//             if((TKA==3)||(TKA==4)||(TKA==5))
//
//              {//Имеется команда на вкл./откл. двигателя нереверсивного привода-?
//                //Выполнена перекодировка команд 1->
//                if((Command_Driv==1)||(Command_Driv==10)) TaskMB =1; //ДА, Вкл. двигатель нереверсивного ...
//
//                                               //ДА, Вкл. вперед двигатель задвижки
//                if(Command_Driv==11) TaskMB =2; //ДА,Откл. двигатель
//                                               //ДА, Вкл. назад двигатель задвижки 18 06 2018
//                if(Command_Driv==2) TaskMB =3; //Да,Отключить двигатель задвижки   18 06 2018
//              }
//
//    if(SBUFrx[3]==3)Reset_Protect1=Temp; //Сброс защиты
//    if(SBUFrx[3]==4)Reset_Protect2=Temp; //Сброс ограничения сбросов защиты,счетчик=0
//         //Ввод  пароля
//    if(SBUFrx[3]==5)
//    {if(Temp==arr[29]){Parol_MB=arr[29];Parol_bt=1;Rec_Setp_MB=0;SetpointMB=0;}
//         //Сброс наличия пароля  кон.
//      else {Parol_MB=Temp;Parol_bt=0;}
//    }
//
//    //Формирование флага-подмены команды Command_Driv=1для реж ДИСТ-АВТ
//    if((TKA==4)&&(Task_Station==1)&&(Command_Driv==1)&&(NU)) Comd_Driv_d=1;
//    if((TKA==3)||(TKA==4)||(TKA==5))
//     { //Имеется команда на вкл./откл. двигателя нереверсивного привода-?
//          //Выполнена перекодировка команд 1->
//      if((Command_Driv==1)||(Command_Driv==10)) TaskMB =1; //ДА, Вкл. двигатель нереверсивного ...
//                                                  //ДА, Вкл. вперед двигатель задвижки
//      if(Command_Driv==11) TaskMB =2; //ДА,Откл. двигатель
//                                      //ДА, Вкл. назад двигатель задвижки 18 06 2018
//      if(Command_Driv==2) TaskMB =3; //Да,Отключить двигатель задвижки   18 06 2018
//     }
//     //Reset_Protect1=(SBUFrx[13]<<8)+SBUFrx[14]; //Сброс защиты
//     //Reset_Protect2=(SBUFrx[15]<<8)+SBUFrx[16]; //Сброс ограничения сбросов защиты,счетчик=0
//         // Принятое сообщение от Модема:                    кон.
//         // Сброс флага самозапуск когда двигатель ВКЛ   нач
//     if((TKA>2)&& (Samo_zp)&&(Kb2_1)&&(!(P4OUT&1)))
//      { //Режим ДИСТ-РУЧ, команда на ОТКЛ двигателя
//        if((TKA==3)&&(Command_Driv==2))Kb2_1=0;
//        if((TKA==4)&&(Task_Station==2))Kb2_1=0;
//      }
//   }
//}
//
//void Nasos (void)   // Функция логики управления насосом
//{  while (!(CommonStatus&0x80)) { if (cntTA0 > Period) CCTL0=0; }   //reset WDT, ecли нет обработки прерывания АЦП
////  if(!(P2IN&2)){Kb2++;if(Kb2>50){Kb2=0;CCTL0=0;}}
////  else Kb2=0;
////  if(Kb2>=4){K11=7;K10=0;goto StopMotor1;}
// //Контроль количество включ. двигателя за 4 мин нач.
//   if((Kz3<20)&&(K10>=Kz3)&&(P4OUT&1)
//     #ifdef GerKTZ
//     &&(P2IN&2)
//     #endif
//    )
//   {KTZ=9;K10=0;}
// //Контроль количество включ. двигателя за 4 мин кон.
//   if(K10){if(Kb1<1200)Kb1++;else Kb1=K10=0;}  //K8=1;(!(P4OUT&1))
//
//   #ifndef EnableNasos
//  // Работа алгоритма при отсутствии насоса
////  IndArray [5]=IndArray [6]=IndArray [7]=LevelStatus_=LevelStatus=0;// Обнуляем показания датчиков уровня
//  if(KTZ)goto StopMotor1;
//  if(TKA>1){if(TKA<4) if (TimePuskStop<TimePuskStopMax/2)return;
//  goto StartMotor;}
//  else{if (!(CommonStatus&8)) goto StopMotor1;
//  if (CommonStatus&8) {if (TimePuskStop>=TimePuskStopMax) goto StartMotor;}
//  return;}
//  #else
//  if((!(CommonStatus&8)))
//    K7=0;
//  else K7=1;//K7=0 использ. при останове по кн.Stop для реж.Автомат
////  if ((IndArray [5]<100)&&(IndArray [6]<100))return;
//     //K7=1;                         //26 04 2018
//  if((TKA<2)&&(!(CommonStatus&8)))K7=0;
//  if((TKA==3)&&(!(CommonStatus&8))&&(TaskMB==1))K7=0; //WD для ДИСТ_РУЧ (=31)
//  if((TKA==4)&&(!(CommonStatus&8))&&(Task_Station==0))K7=0; //WD для ДИСТ 31
//
//  // Определяем состояние нижнего уровня
//  if (IndArray [5] < LevelUst)LevelStatusNew |=1;
//  else LevelStatusNew = LevelStatusNew & (~1);
//  if ((LevelStatusNew&1)!=(LevelStatus_&1)) TimeLow++;
//  else  TimeLow=0;
//
//  // Определяем состояние верхнего уровня
//  if (IndArray [6] < LevelUst)LevelStatusNew |=2;
//  else LevelStatusNew = LevelStatusNew &(~2);
//  if ((LevelStatusNew&2)!=(LevelStatus_&2))TimeHi++;
//  else  TimeHi=0;
//
//  // Определяем состояние аварийного уровня
//  if (IndArray [7] < LevelUst)LevelStatusNew |=4;
//  else LevelStatusNew = LevelStatusNew & (~4);
//  if ((LevelStatusNew&4)!=(LevelStatus_&4)) TimeDry++;
//  else  TimeDry=0;
// if(((!(TimeLow))||(TimeLow>=TimeHistLowLev))&&((!(TimeHi))||(TimeHi>=TimeHistHiLev))&&
//    ((!(TimeDry))||(TimeDry>=5*Kz5))
//   )
//  {LevelStatus_=LevelStatusNew;goto UprN;}
// else goto Psk1;   // Не производим дальнейшую обработку пока все уровни не стабилизируются
//
//UprN:
//// #ifdef Ppusk
//// if ((!(P4OUT&1))&&(!(LevelStatus_&8)))KTZ=5;//(LevelStatus_&8)
//// #endif
// #ifdef TK112M
// if(LevelStatus_&4)
// #else
// if(!(LevelStatus_&4))
// #endif
// {if((!(KTZ))&&(Tim_KTZ_6==0))
//   {Tim_KTZ_6=(arr[ZD_Avar_CX]*5);} //TimeCX константа 31 (равная 6 сек) заменена регулируемой уставкой ZD_Avar_CX
//                   //arr[TimeCX],  12 04 2019
//    if(!(KTZ))Tim_KTZ_6--;
//    if(!(Tim_KTZ_6))
//     {KTZ=6;Tim_KTZ_6=0;goto StopMotor1;}
// } // выключаем двигатель, если сухой ход по датчику  пуск
//   if(TimePuskStop<TimePuskStopMax)goto Psk1;
//   //WAS блокируем работу по датчикам 22 05 2018
//  if((TKA==1)||(TKA==3)||
//     ((TKA==4)&&(TaskMB==1)&&((Command_Driv==1)||(Comd_Driv_d==1))&&(NU)&&(!(VU)))) goto Pusk1;
//   // Считываем из FLASH уставку - подача или откачка
//  pword1 = (unsigned int *)(Flash_SegA + 2*PodOtkSelSens);
//
//    switch (*pword1)                        //
//     {case 0:goto Otkachka; // Otk
//      case 1:goto EKM; // ЭКМ
//      case 2:goto Electrod;//Электроды
//      case 3:goto ItalyPress;//Другие
//      case 4:goto POPL;// Другие
//     default:goto StopMotor1;
//     }
//    // Датчик ЭКМ
//   EKM:
//      switch (LevelStatus_&0x03)
//      {case 0:goto Rab1;//LevelStatus=0; TimeStartNasos=0;
////             if(!(K7))goto StopMotor1;return;     // На индикатор символ -,  если кнопка стор нажата, то...
//       case 1: LevelStatus=2;goto Pusk1;
////             if(!(K7))goto StopMotor1;goto StartMotor; // включаем двигатель, если давление низкое На индикатор символ L,  если кнопка стор нажата, то...
//       case 2: LevelStatus=1;goto StopMotor;  // выключаем двигатель, если давление высокое На индикатор символ Н
//       case 3: goto NDU;                     //если два контакта замкнуты одновременно, то выключаем двигатель  код защиты - авария датчика
//         }
//    // Датчик элетрод
//   Electrod:
//      switch (LevelStatus_&0x03)
//     { case 0:LevelStatus=2;goto Pusk1;
////             if(!(K7))goto StopMotor1;goto StartMotor;     // Нижний уровень, включаем двигатель на индикатор символ L,  если кнопка стор нажата, то...
//       case 1:goto Rab1;//LevelStatus=0; TimeStartNasos=0;
////             if(!(K7))goto StopMotor1;return;                     // Уровень нормальный: на индикатор символ "-",  если кнопка стор нажата, то...
//       case 3:LevelStatus=1;goto StopMotor;         // Верхний уровень, выключаем двигатель, на индикатор символ H
//       default: goto NDU;                            // неисправность датчика: выключаем двигатель,
//     }
//
//    // Датчик давления итальянский
//    ItalyPress:
//        if(!(LevelStatus_&0x01)){LevelStatus=1;goto StopMotor;}  // выключаем двигатель, если давление высокое На индикатор символ "-"
//        else {LevelStatus=2;goto Pusk1;}
////        if(!(K7))goto StopMotor1;goto StartMotor;} // включаем двигатель, если давление низкое На индикатор символ L
//
//    // Датчик давления итальянский
//    POPL:
//        if(LevelStatus_&0x01){LevelStatus=2;goto StopMotor;}  // выключаем двигатель, если давление высокое На индикатор символ "-"
//        else {LevelStatus=1;goto Pusk1;}//if(!(K7))goto StopMotor1;goto StartMotor;} // включаем двигатель, если давление низкое На индикатор символ L
//
//    Otkachka:  // Иначе откачка. Электорды, дренажные приямки.
//     switch (LevelStatus_&0x03)
//      {case 0:LevelStatus=2;goto StopMotor;           // Нижний уровень, выключаем двигатель на индикатор символ L
//       case 1:goto Rab1;//LevelStatus=0; TimeStartNasos=0;
////             if(!(K7))goto StopMotor1;return; // Уровень нормальный: на индикатор символ "-"
//       case 3:LevelStatus=1;goto Pusk1;
////     }        if(!(K7))goto StopMotor1;goto StartMotor;          // Верхний уровень, включаем двигатель, на индикатор символ H
//       default:goto NDU;}
//  Rab1:LevelStatus=K11=0;
//  #ifndef TKM
//     if((!(K4))&&(K7))goto StartMotor;
//  #endif
//     TimeStartNasos=0;
//     if(!(K7))goto StopMotor1;
//     return; // Уровень нормальный: на индикатор символ "-"
////  Rab1:LevelStatus=0; TimeStartNasos=0;
////     if((!(K4))&&(K7))goto StartMotor;if(!(K7))goto StopMotor1;return; // Уровень нормальный: на индикатор символ "-"
//  NDU: K11++;
//     if(K11<20)return;
//  else{KTZ=7;goto StopMotor1;}
//  Pusk1:if(!(K7))goto StopMotor1;
//  else  goto StartMotor;
//
//  StopMotor:
//    StateMB=1;
//    K11=0;if (!(P4OUT&1))
//            {pword1 = (unsigned int *)(Flash_SegA + 2*DeleyStopN);
//  #ifdef Kras
//     if(TimeStopNasos<*pword1*300)TimeStopNasos++;
//  #else
//      if(TimeStopNasos<*pword1*5)TimeStopNasos++;
//  #endif
////       TimeStopNasos++; //Делаем задержку перед включением насоса при управлении алгоритмом НАСАС
//                 else goto StopMotor1;
//                 }return;
//  Psk1:if(!(K7))goto StopMotor1;else return;
//  #endif
////  Psk1:if(!(K7))goto StopMotor1;else return;
//  StopMotor1:
//    StateMB=1;
//    K11=0;//if((!(P3IN&0x40))&& (!(Rj_VU_P))){P4OUT=2;return;}
//   if(((TKA==2)||(TKA==4)||((TKA==3)&&(!(CommonStatus&8)))||
//       (((TKA==1)||(TKA==5))&&(Pusk_On==0)))&& (!(P4OUT&1)))
//      {TimeStopNasos=TimeStartNasos=TimePuskStop=Kz2=0;P4OUT=3; TaskMB=0;
//       if((TKA==4)&&(TaskMB==1)&&(Command_Driv==1)&&(NU)&&(VU))Command_Driv=Comd_Driv_d=2;
//      }
//         return;
//  StartMotor:
//     //WAS ПУСК упраквление от ВУ
//    StateMB=2;
//    K11=0;if((P4OUT&1)&&(!(KTZ))  && ((TaskMB==1)||(Pusk_On==1)||(Task_Station==1)))
//             {pword1 = (unsigned int *)(Flash_SegA + 2*DeleyStartN);
//  #ifdef Kras
//     if(TimeStartNasos<*pword1*300)TimeStartNasos++;
//  #else
//      if(TimeStartNasos<*pword1*5)TimeStartNasos++;
//  #endif
////              if(TimeStartNasos<*pword1*5)TimeStartNasos++; //Делаем задержку перед включением насоса при управлении алгоритмом НАСАС
//      else {TimeStartNasos=TimePuskStop=Kz1=0;K4=1;K10++;if((TaskMB==1)||(Pusk_On==1)){P4OUT=2;TaskMB=0;}}
//             }
//             return;
// }
//
//
//# include "ButtDisp2var.c"
//
//#ifdef EnableRS232
// # include "Prot232var2.c"
//#endif
//
//void main (void)
// {  // Инициализация WDT  (при включении контоллера WDTCTL = 0х6900)
//                                               WDTCTL=WDT_MRST_32; // Сбрасываем WDT
//    ww=arr[0];//WAS инициализация массива arr
//    ww=arr1[0];
//    _EINT();  // Разрешаем прерывания
//    Init (); // Предварительная инициализация устройства
//
//    while (1)
//     {  LOOPInit (); // Инициализируем устройство в каждом цикле
//        _EINT();  // Разрешаем прерывания
//        // Определяем измеряемый диапозон тока и выставляем
//        //соответствующий коэффициент усиления
//      #ifdef EnableConvert
//         DefineDiap ();
//      #endif
//        // Считываем из Flash уставку по диффзащите и перерасчитываем её в биты
//      DiffLevel=CalcInp();
//
//       #ifdef EnableRS232
//       if (!(UCTL0&LISTEN))  // Если нет прередачи по интерфейсу
//          {  // Считываем из Flash адрес и скорость обмена
//             pword1=(unsigned int*)(Flash_SegA + 2*AdressBaudRate);
//             Adress=*pword1/256;
//             switch(*pword1%256)
//             {case 3:  UBR00=0x1b;UMCTL0=0x24;break;   // 2400
//              case 4:  UBR00=0x0d;UMCTL0=0x6d;break;   // 2400
//              case 5:  UBR00=0x06;UMCTL0=0xEF;break;   //4800
//              default: UBR00=0x03;UMCTL0=0x4a;         //9600
//             }
//           }
//       #endif
//         // Если устройство находится в режиме калибровок, то только измереяем и индицируем
//       if ((!(P3IN&0x40))||(g3))
//        {MeasureAndCalcCurrent();Nasos();
//         Isolation ();
//         goto DispleyAndButton1;}
//      #ifndef DiffZasch
//       #ifdef OBPH
//       else{if(P4OUT&1)K13=K14=0;
//          else{K14++;if(K14>=1800){K14=0;K13++;}
//               pword1 = (unsigned int *)(Flash_SegA + 2*IdiffMax);
//               if(K13>=*pword1)KTZ=5;}}
//       #endif
//      #endif
//      if((KTZ)&&(TKA>=3)&&(K4>=4)&&(Reset_Protect1==1))  //сбросить Аварию по команде
//       {if(Reset_Protect1==1)
//          TaskKTZ=1; //Сбросить защиту
//        else TaskKTZ=0;                  //Защиту не сбрасывать
//       }
//      if(KTZ)
//       { if(KTZ==4)Isolation ();
//         goto DispleyAndButton;} // Если возникла авария, то работаем только с кнопками
//                                 //и дисплеем и выключаем АЦП
//      // Выполняемый алгоритм
//     K4++;if(K4<4){ goto n10;}   //WAS Задержка на 4 цикла, после которой можно выдавать сообщения ???
//     if(K4>=4)
//      { K4=4;
//        l7=0;//l5++;????
//        //Формирование Аварии при отказах по связи МБ   нач
//        if(SL_Master)
//         {if((!(KTZ))&&(i10<=300))i10++;//счет сканов по отказах по связи МБ
//           else {/*KTZ=12;*/i10=0;}//отказ по МБ //По требов. И.О. убран отказ по МБ СМИ
//         }
//            //Формирование Аварии при отказах ..... кон
//        //Включение насоса в реж.АВТОМАТИЧЕСКИЙ
//        if(TKA==2)Pusk_On=1;
//          //Преобразование режимов и задания для ответа на запросы МБ нач
//          //режим текущий, выдаваемый в МБ
//        if(TKA<3){TKA_MB=TKA;}//Режимы РУЧН,АВТОМАТ или не задан (=0)
//         else {//Разновидности режима ДИСТАНЦ.
//               if(TKA==3) TKA_MB=31;//Работа по команде диспетчера
//               if(TKA==4) TKA_MB=32;//Работа по станции автоматической
//               if(TKA==5) TKA_MB=33;//Работа ручная дистанционная особая
//              }
//         //Режим заданный TKA_zdn, выдаваемый в МБ
//         if(TKA<3)TKA_zdn= arr[TK_A];
//           else {//Разновидности режима ДИСТАНЦ.
//                 if(arr[TK_A]==3)TKA_zdn=32;
//                 if(arr[TK_A]==4)TKA_zdn=31;
//                }
//           //Преобразование режимов и задания для ответа на запросы МБ кон
//        //Преобразование задания TaskMB==2)||Pusk_On==1)
//        if(TKA==1)
//          {if(Pusk_On==1)TaskMB_RAD =1;
//            else TaskMB_RAD =2;
//          }
//        if(TKA==2)
//         {if(CommonStatus&0x08)TaskMB_RAD=1;
//           else TaskMB_RAD=2;
//         }
//        if(TKA>=3)TaskMB_RAD =TaskMB;
//        if(TKA==5)TaskMB_RAD =Command_Driv;
//          //Преобразование режимов и задания для ответа на запросы МБ кон
//          //Заполнение значений уровней для ответа по МБ нач
//        if (LevelStatus_&0x01) NU=1; //Имеется ВУ
//            else NU=0;    //Нет ВУ
//          if (LevelStatus_&0x02) VU=1; //Имеется НУ
//            else VU=0;    //Нет НУ
//          if (LevelStatus_&0x04) SU=1; //Имеется CX (CУ)
//            else SU=0;    //Нет CX (CУ)
//           //Заполнение значений уровней для ответа по МБ нач
//          //Состояние мотора
//           if (!(P4OUT&1))St_Driv=1; //Мотор включенный
//            else St_Driv=0; //Мотор выключенный
//
//         //Реализация команд и данных, переданных по сети Модбас  нач.
//           //Переключить режим работы станции согласно команде на установку режима
//           //и это возможно, если установлен режим ДИСТАНЦИОННЫЙ (т.е.ТКА >=3
//           //Переключить в режим ДИСТАНЦ-АВТОМАТ (т.е. ТКА=4)
//            //Команда -работа автоматическая (по датчикам)-?
//        if((RJ_Mod==33)&&(TKA!=5)&&(TKA>=3))
//          {//ДА, переключить в режим ДИСТАНЦ-РУЧН-КН-Пожар (т.е. ТКА=5)
//             TKA=5;write_Flashw (TKA,TK_A); // //Уст. режим ... и во Flash
//          }
//        if((RJ_Mod==32)&&(TKA!=4)&&(TKA>=3))
//          {//ДА, переключить в режим ДИСТАНЦ-АВТОМАТ (т.е. ТКА=4)
//             TKA=4;write_Flashw (TKA,TK_A); //Уст. режим ДИСТАНЦ-АВТОМАТ, и во Flash
//          }
//            //Команда -работа по команде диспетчера
//        if((RJ_Mod==31)&&(TKA!=3)&&(TKA>=3))
//         {//ДА, переключить в режим ДИСТАНЦ-РУЧН (т.е. ТКА=3)
//            TKA=3;write_Flashw (TKA,TK_A);
//         }
//         //Выполнение команд в режиме ДИСТАНЦИОННЫЙ
//        if(((TKA==3)||(TKA==4))&&(!(Kb2_1)))
//         { if(!(KTZ))
//           {//Режим ДИСТ-АВТОМАТ-?
//             if(TKA==4)
//              {//ДА
//                //Запущена автоматическая работа -?
//                if(Task_Station==1) TaskMB =1; //ДА,Включить двигатель
//                if(Task_Station==2) TaskMB =2; //НЕТ,Отключить двигательь
//              }
//              //Режим ДИСТ-РУЧН-?
//             if(TKA==3)
//              {//Имеется команда на вкл. двигателя -?
//                if(Command_Driv==1) TaskMB =1; //ДА, Включить двигатель
//                if(Command_Driv==2) TaskMB =2;//НЕТ,Отключить двигатель
//              }
//           }
//        }
//         //Реализация команд, переданных по сети Модбас  кон.
//        // Включение/ выкщючение привода
//        if (!(P4OUT&1))                                 // Если двигатель включён
//         { MeasureAndCalcCurrent();PhaseMaxMinAssim();
//          #ifdef Ppusk
//           Isolation ();
//           #endif
//          #ifndef EnableNasos
//           if((!(CommonStatus&1))&&(TKA>1))Isolation ();// Измеряем силу тока,
//                                                  //проверяем защиты по току
//          #endif
//        }
//       else{PhaseMax_O=PhaseCx_O=RemPhaseMax=RemPhaseCx=Assim_O=RemAssim=0; //при
//                            //выключенном двигателе обнуляем значения максимальных
//                            //и минимальных токов и ассиметрию
//           IndArray[0]=IndArray[1]=IndArray[2]=0;IndArray[3]=0;
//           Assim_O_Prz=0;
//           Isolation ();
//          }
//     }
//    DispleyAndButton:
//     Nasos();            // управляем насосом
//     if(KTZ)
//      {P4OUT=1;K10=0;CommonStatus&=(~1);MeasureControl=0;//CommonStatus&=0xF2;
//        if(((KTZ==6)&&(TimeCXN<250))||((Kz8&1)&&(KTZ==3))||(KTZ==8))
//        {K8++;if(KTZ==8){TimeCXN=15;if(K8>=300){K8=0;TimeCXNasos++;}}
//         else {if(!(Kz8&2)){if(K8>=5){K8=0;TimeCXNasos++;}}          //сек
//               else{if(K8>=300){K8=0;TimeCXNasos++;}}}               //мин
//         if(TimeCXNasos>=TimeCXN)
//         {TimeCXNasos=MeasureControl=KTZ=0;}
//        }
//      }
//   DispleyAndButton1:
//    if((!(P3IN&0x40))||(g2))g3=1; //Устан. Пароль без перемычки Пароля 16 05 2018
//    if((P3IN&0x40)&&(!(g2)))g3=0; //Снять Пароль без перемычки Пароля  16 05 2018
//   //Коррекция тока кнолками- нач ???
//   //Коррекция тока кнолками- кон ???
//    TimeCode105++;        //Увеличить счетчик обменов 24 06 2018
//    TimeCode106++;
//    TimeCode110++;
//
//     if(SL_Master)
//     { if(SBUFrx[0]==ADR_SMI2){SBUFrx[0]=0;Quer_MB=1;} //Блокировка приема от Подчиненной
//       //Данная станция должна отображать на дисплее СМИ несмотря на аварию
//       //на аварию (KTZ!=0) или временное отсутствие ответа от СМИ  нач.
//        if((i10>10)||(KTZ!=0)){SBUFrx[0]=0;Quer_MB=1;K5=0;}
//                                         //Данная станция должна ...кон
//        if((!(l1))&&(!(K5&0x01))&&(SBUFrx[0]==0)&&(Quer_MB==1))
//          //Выдача запроса по Модбаc по функции 110 согласно очереди обслуживания
//        {IE1&=~URXIE0;ME1&=~URXE0;}
//         else goto n11;
//
//         //Формирование запроса для СМИ2 АДР 16 (10Н)
//         /*
//         Формирование запроса СМИ2 всего 13 байт
//          №бит	0    1	  2   3   4	5   6	7    8	  9    10   11	 12
//          Наим	АДР  Функ Рег ... Порт  ... Кол.байт Циф1 Циф2 Циф3 Циф4 CRC	CRC
//          Знач	10   10	  00   21  00	02	04   F2	  FC	F3  60
//         */
//         SBUFtx[0]=0x10;
//         SBUFtx[1]=0x10;   //Функция =10H
//         SBUFtx[2]=0x00;     //Рег нач =00H
//         SBUFtx[3]=0x21;     //Рег кон =21H
//         SBUFtx[4]=0x00;     //Порт нач =00H
//         SBUFtx[5]=0x02;     //Порт кон =02H
//         SBUFtx[6]=0x04;     //Кол. байт в портрете =02H
//         SBUFtx[7]=SBUFtx[8]=SBUFtx[9]=SBUFtx[10]=0;
//         if(Diapozon<3)Point4=7;
//         if(Diapozon==0)Point4=6;
//         Temp=IndArray [0]; //значение тока фазы А
//           //Temp=4;  //Debug 7001, 301, 1
//           //Point4=7;  //Debug
//         //1-я цифра, которая записывается с места Info[6] дисплея системы нач
//         i2=Temp/1000;   //старшая цифра
//         if(!(i2))SBUFtx[7]=0; // если цифра =0, то ее "Портрет" это пробел (" ")
//          else SBUFtx[7]=portr[i2]; //если цифра !=0,!=0, то ее "Портрет" с массива portr[i2]
//              //1-я цифра, ... Info[6] дисплея кон
//          //2-я цифра, которая записывается в места Info[7] дисплея системынач
//         Temp=Temp%1000;i2=Temp/100;
//         if((!(i2))&&(!(SBUFtx[7]))&&((Point4!=6)))SBUFtx[8]=0; //если предыдущие цифры =0,ее "Портрет"  пробел
//          else
//           {if(i2)SBUFtx[8]=portr[i2]; // "Портрет" с массива portr[i2]
//            if((!(i2))&&((Point4==6)||(SBUFtx[7]!=0)))SBUFtx[8]=0xFC;//то "Портрет" значения 0
//           }
//          if(Point4==6)SBUFtx[8]+=1; //занести точку (т.е.запятую для дробного числа)
//              //2-я цифра, ...Info[7] дисплея кон
//          //3-я цифра, которая записывается с места Info[8] дисплея системы нач
//         Temp=Temp%100;i2=Temp/10;
//         if((!(i2))&&(SBUFtx[7]==0)&&(SBUFtx[8]==0)&&(Point4!=7))
//                SBUFtx[9]=0;//то "Портрет" пробел
//          else{ if(i2)SBUFtx[9]=portr[i2]; //если цифра !=0, то ее "Портрет" с массива portr[i2]
//                if(!(i2))SBUFtx[9]=0xFC;//то "Портрет" значения 0
//              }
//         if(Point4==7)SBUFtx[9]=SBUFtx[9]+1;
//             //3-я цифра, ...Info[7] дисплея кон
//          //4-я цифра, которая записывается с места Info[8] дисплея системы нач
//         i2=Temp%10;
//         if(!(i2))SBUFtx[10]=0xFC; // если цифра =0, то ее "Портрет" значения 0
//          else SBUFtx[10]=portr[i2]; //если цифра !=0,!=0, то ее "Портрет" с массива portr[i2]
//            //4-я цифра, ...Info[7] дисплея кон
//
//          /*
//         if(Point4==2)SBUFtx[9]=SBUFtx[10]+1;//Показать "," на портрете цифры
//         Temp=Temp%100;i2=Temp/10;
//         if(!(Point4))
//           {if((!(i2))&&(!(SBUFtx[7]))&&(!(SBUFtx[8])))SBUFtx[9]=0;
//            else SBUFtx[10]=portr[i2];}
//          else{if(Point4==2)SBUFtx[10]=portr[i2];
//         if(Point4==1)SBUFtx[10]=portr[i2]+1;}
//         i2=Temp%10;SBUFtx[10]=portr[i2];
//          */
//         //
//
//         i2=11;
//        //подготовка к передаче
//        P3OUT|=0x80;
//        K5|=1;P3SEL=0x30;                     //подготовка к передаче
//        K14=0; //?????
//         //Подсчет CRC
//        Temp2=CRC_16((unsigned char*)&SBUFtx[0],i2);    //KC контрольная сумма
//        SBUFtx[i2]=Temp2%256;SBUFtx[i2+1]=Temp2/256;i2=i2+2;//младший байт KC затем старший
//        i3=0;TXBUF0=SBUFtx[i3]; ME1|=UTXE0;IE1|=UTXIE0;      //разрешение прерывания по передаче передача адреса
//        SBUFrx[0]=Quer_MB=0; //Quer_MB; //Был ответ
//       }
//    /////
//   n11:
//   n10:
//         while (cntTA0 < Period )
//          {Button();
//            #ifdef EnableRS232
//             Answer(); // Ожидаем окончания периода
//                      //цикла 200ms c опросом кнопок
//            #endif
//          }
//        cntTA0=0;
//        if (!(P4OUT&1))St_Driv=1; //Мотор включенный
//            else St_Driv=0; //Мотор выключенный
//        ButtonDisp ();FlashDisp();Butt=0;
//        Display ();
//         //Функция сброса n-го экрана   25 04 2018  нач.
//        if((INDMODE==INDMODE_old)&&(INDMODE!=0))
//         {if(cnt_sbr_scrn<300)cnt_sbr_scrn++;
//          else INDMODE=INDMODE_old=0; //переключить -й экран в 0-й
//         }
//        else cnt_sbr_scrn=0;
//        if(((INDMODE!=INDMODE_old)&&(INDMODE!=0))||(More_d)||(Less_d))
//        { cnt_sbr_scrn=More_d=Less_d=0;INDMODE_old=INDMODE;}
//         //Функция сброса n-го экрана   25 04 2018  кон.
//       if (TimePuskStop<TimePuskStopMax)TimePuskStop++;
//       if (TimeStart<TimeStartMax) TimeStart++;
//       if(TimePuskStop<TimePuskStopMax)TimePuskStop++;
//       if(!(KTZ))P4OUT|=2;
//     //Запись во Flash принятой уставки по МБ 27 11 2019  нач.
//       VU_NU_SX= (VU<<2)+(NU<<1)+ SU;
//      if((Rec_Setp_MB)&&((SetpointMB)||
//            ((!(SetpointMB))&&(((ADR_SetpointMB==3)||(ADR_SetpointMB==255)||
//              (ADR_SetpointMB==3)||(ADR_SetpointMB==24)||(ADR_SetpointMB==26)))))) //разреш.0 уставку
//        write_Flashw(SetpointMB,ADR_SetpointMB);
//      if(arr[ADR_SetpointMB]==SetpointMB){
//       Rec_Setp_MB=SetpointMB=0;
//      }
//     //Запись во Flash принятой уставки по МБ 27 11 2019  кон.
//     //Функция сброса n-го экрана   25 04 2018  кон
//         //Сброс защиты по команде в режиме ДИСТ нач.
//         if ((KTZ)&&(!(arr[Tkz]))&&(!(Reset_Protect2))&&(Reset_Protect1==1))
//            {if ((TaskKTZ==1)&&(CounterKTZ<3))
//             { KTZ=0;
//               Reset_Protect1=0;
//               TaskKTZ=0;
//               CounterKTZ++;
//              }
//            }
//           if(Reset_Protect2)CounterKTZ=0;
//         //Сброс защиты по команде в режиме ДИСТ кон.
//   }   //конец while()
// }     //конец ПП main()
//
