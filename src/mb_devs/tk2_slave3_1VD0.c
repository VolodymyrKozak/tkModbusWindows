/*
  * tk2_slave3_1VD0.c
 *
 *  Created on: 21 лист. 2019 р.
 *      Author: KozakVF
 */

             //    Головной файл для устройства защиты электродвигателя //TkA_N16
        //исключено запоминание /ПУСК/  NumSamples=248;
//#include  <msp430x13x.h>                // Standard Equations
#include "tk2_slave3_1.h"
#include  <math.h>
#include "stdint.h"
#define Serial     0    // Серийный номер изделия от 0 до 65535
#define Modif      20   // Номер модификации изделия в завсимости от алгоритма, типов датчиков и др.
                        // от 0 до 255 (рекомендуется от 20)
#define EnableNasos     // Комментирование этой директивы выключает программный блок управления насосом//
#define EnableConvert   // Комментирование этой директивы позволяет выводить на индикатор битовые значения всех токов
//#define EnableRS232   // Комментирование этой директивы запрещает обмен по интерфейсу

//#define TK              // Комментирование этой директивы позволяет перейти от ТК к ТК112-1
//#define DiffZasch     // Комментирование этой директивы запрещает работу дифзащиты
#define Dt_nov          // Комментирование этой директивы позволяет перейти с Rvx=1,2 0m на Rvx=3,9 Om

//#define ZaschTV     // Комментирование этой директивы запрещает работу защиты по температуре и влажности
//#define Kras           // Комментир этой дир позвол перейти от задержек в мин к зад в сек
//#define OBPH           // Комментирование этой директивы позволяет запретить ограничение
                        //времени работы насоса(OBPH)
//#define TKM           // Комментирование этой директивы позволяет перейти от ТКM к ТК
//#define TK112M        // Комментирование этой директивы позволяет перейти от платы ТК112М к       //
//#define Ppusk           // Комментирование этой директивы позволяет перейти от Ppusk к ТК
#define GerKTZ        // Комментирование этой директивы позволяет запретить сброс KTZ
                        // от кнопки СТОП
#define Period    200   // Длительность одного цикла, ms  /200
#define TauLevel  2     // Постоянная времени для датчиков уровня, s
#define TauIzol   3
#define Parol     3     // Пароль для ввода уставки без перемычки пароля

   //Количество байт(вместе с CRC)принимаемых Подчиненным по функциям в запросе МБ
#define ColByt_F105     4 // Для фунции 105
#define ColByt_F106     4 // Для фунции 106
#define ColByt_F110     9 // Для фунции 110
   // Постоянная времени для защиты по сопротивлению изоляции, s.
#define TauIcx    1     // Постоянная времени для защиты по току сухого хода
#define TauIasim  10     // Постоянная времени для защиты по току ассиметрии //7 10

#define  TauIndI   1//4     // Постояная времени вывода на индикатор показаний тока
#define  DiffZerro2 2000  //23,200,242
#define TimeStartMax     20  //Время блокировки команды "Start"
#define TimePuskStopMax  20//0//10 //Время пуска или останов двигателя 50*200(Period)=10000 ms=10s  20
#define TimeIsol         2 //10 // Время задержки определения защиты изоляции(с прогрм. закороткой входа и выхода  фильтра изол.) после выключения-выключения ЭД или после сброса (включения) устройства
                              // Причём !!!ДОЛЖНО!!! (TimePuskStopMax>TimeIsol); (TimePuskStopMax-TimeIsol) определяет гарантированное время расчёта изоляции.
#define TimeHistHiLev    5 // Временной гистерезис для датчика верхнего уровня
#define TimeHistLowLev   5 // Временной гистерезис для датчика нижнего  уровня   20
//#define TimeHistDryLev   40 // Временной гистерезис для датчика сухого   уровня
//#define TimeHistBlock    20
//#define   BlockUst       900
//#define   LevelUst       900  // Порог срабатывания датчиков уровня в битах
//#define   IsolUst        380  // Порог срабатывания датчика сопротивления изоляции в битах
#define   ValueLimited   9990  // Ограничитель значения изменяемой уставки Value
#define   Y2diff          30  // Значение Y2 для калибровки по диффзащите

// Константы определяющие сегменты Flash памяти, где хранятся уставки и калибровки
#define Flash_SegA 0x1000 // Рабочий сегмент,   1040
#define Flash_SegB 0x1080 // Резервный сегмент  10C0
          // Смещения в длинной в  слово от начала сегмента
#define Contr1        0
#define Adress        1  // Для вызова адреса с массива Flash

#define Imax1kVt      2   // 1 - уставка защиты по току Iмах (1 кВт двигатель)
#define Icx1kVt       3   // 3 - уставка защиты по току сухого хода Iсх (1 кВт двигатель)
#define TauI          4   // 6 - уставка постоянной времени защиты по току (Iн)
#define PodOtkSelSens 5   // 9 - уставка подача или откачка и выбор датчика ( оЭ=0 - откачка
                          // Электрод(Э)/ПЕ=1-подача ЭКМ/ПЭ=2-подача(Э)/оП(лрочие)=3 )
#define DeleyStartN   6   //Задержка перед пуском насоса в регулировании по уровню 50*200(Period)=10000 ms=10s
#define DeleyStopN    7  //Задержка перед остановом насоса в регулировании по уровню 50*200(Period)=10000 ms=10s
#define PowerMotor    8   // 15 - выбор номера кольца тока (1/2/3/4)
  // Калибровки дифзащиты
#define X1Diff        9   // 30 - X1 диф   фзащиты
#define X2Diff       10   // 31 - X2 диффзащиты
#define IdiffMax     11   // 8 - уставка защиты по дифф току
                          // Калибровки
      //Входные сигналы для первого поддиапазона(Большой коэффициент усиления)
#define X1A1         12    // 18 - X1 фазы А
#define X2A1         13    // 19 - X2 фазы A
#define X1B1         14   // 22 - X1 фазы B
#define X2B1         15   // 24 - X2 фазы B
#define X1C1         16   // 26 - X1 фазы С
#define X2C1         17  // 28 - X2 фазы С

#define TimeCX       18  // 30 -
#define UstZach1     19  //Уставка для регулирования температуры и влажности
#define kol_zap      20 //UstZach->kol_zap Кол.запуск за 4 мин  21 04 2018
#define IsolUst1     21  // Порог срабат.датчика сопротивл. изоляции  или Пл.Пуска в битах
#define LevelUst1    22  // 10 - уставка выбор датчика (ЭКМ =0/Электрод=1/Итальянский=2)
#define TK_A         23  // 34 - WD - запоминание режима TKA во Flash
#define samozap      24  //Cамозапуск  21 04 2018 (UstZach3-> samozap), ранее Kb2
#define UstZach2     25
#define PP_Isol      26  //Выбор Плавного Пуска или Изоляцию
#define ZD_Avar_CX   27  //Задержка включения аварии датчика СХ
#define Ust_PP       28  //Уставка для Плавного Пуска

#define ver_prj      32  //версия проекта
#define Tkz          33   // Запись аварии во Flash (т.е. KTZ)
#define Contr3       34   //Указатель, равный количества записей уставок во Flash
                         //Хранение K10 - количество включений двигателя, запом. при аварии
#define Contr4       35   //время рвботы в час
#define IndArr0      36   // Ток Ia при возникновении аварии при пере/недогрузке
#define IndArr1      37   // Ток Ib при возникновении аварии при пере/недогрузке
#define IndArr2      38   // Ток Ic при возникновении аварии при пере/недогрузк
#define Contr2       39   //
#define UstZach      34   //UstZach->.. 25 04 2018, свободно
#define kol_faz      30   //Кол.фаз и датчиков тока  21 04 2018
#define UstZach3     35   //UstZach3  25 04 2018, свободно
#define CRC1         40   //СRC массива arr для уставок и записываемых
                          //параметрах при перезапусках,если KTZ!=0
#define PrZ          41  //Предел записи в массив arr

#pragma memory=constseg(INFO)
unsigned int arr[] /* @ Flash_SegA*/ ={101,0x0002,3000,0,90,2,1,1,3,4,248,50,//133/50mA(400A),188/50mA(100A),235/50mA(25A)  //Уставки //WAS 0xFFFF - 1*256+0x21
                                  //      0,    1,   2, 3, 4,5,6,7,8,9, 10,11
                                  //     [0]=Контр Flash
                                  //           [1]=АДР МБ
                                  //               [2]=Iмах
                                  //                   [3]=Iмin
                                  //                       [4]=Tнагр
                                  //                         [5]=0 откачка,=2 подача
                                  //                           [6]=Тзадержки ВКЛ по уровню
                                  //                             [7]=Тзадержки ОТКЛ по уровню
                                  //                               [8]= типоразмер
                                  //                                 [9]=X1 диффзащиты
                                  //                                     [10]=X2 диффзащиты
                                  //                                     [11]= уставка защиты по дифф току
      # ifdef Dt_nov
                       2,441,1,440,3,442, //441,440,442    //130ед/300A
                   // 12, 13,14,15,16,17
                   //[12]=X1 тока фазы А
                   //    [13]=X2 тока фазы A
                   //       [14]=X1 тока фазы B
                   //          [15]=X2 тока фазы B
                   //             [16]=X1 тока фазы C
                   //                [17]=X2 тока фазы C
         # else
                       2,660,1,660,3,660,
        # endif
      #ifdef TK112M
                   254,
       #else
        #ifdef ZaschTV
                   254,
       #else
                   10,
                //[18]=TimeCX задержка сброса по сух.ходу
       #endif
     #endif
                   4,5,
                //[19]=UstZach1 -> Kz5 уставка по  Т и Влажности
                //  [20]= UstZach->kol_zapkol_zap, Кол.запуск за 4 мин
       //#ifndef Ppusk //WAS
                   380,   //WAS 21 //Уставка контроля Изоляции
      //#else   //WAS
      //           700,  //WAS 21 -плавный пуск
      //#endif
                  1000,  // [22]= Порог срабатыв. датчиков уровня
                     1,  //  [23]= Режимы управления Р=1(руч.реж Р),А=2,Д=3...
                     0,  //  [24]= уставка UstZach3 -> samozap, ранее Kb2
    #ifndef EnableNasos
                     0, // [25]= включить насос //UstZach2- Kz8
   #else
                     3, // [25]= отключить насос

   #endif
                     0,10, 700, 0, 1, 0, 50203,
              //WAS 26,27,  28,29, 30,31,32,
              //   [26]= 1, выбран Пл.Пуск,=0 выбрана Излдяция
              //      [27]= ZD_Avar_CX - Задержка включения аварии датчика СХ
              //           [28]= = 700, Уставка для Пл.Пуск
              //              [29]=рез
              //                  [30]=kol_faz(Кол.фаз, т.е.1фаза,3фазы и 2 датч.,3фаз и 2 датч)
              //                     [31]=рез
              //                       [32]=ver_prj?,версия проекта
                     0,  2, 255,256,257,16, 33,22709 //55531
              //WAS 33, 34, 35, 36, 37, 38, 39, 40
              //   [33]= Tkz(Авар.знач. TKZ во Flash)
              //       [34]= Contr3
              //           [35]= Contr4
              //               [36]=IndArr0 - запись тока Ia при Аварии
              //                   [37]=IndArr1 - запись тока Ib при Аварии
              //                       [38]=IndArr2 - запись тока Ic при Аварии
              //                           [39]=Contr2
              //                              [40]=СRC
};
const unsigned int arr1[]/* @ Flash_SegB */={101,0x0002,3000,0,90,2,1,1,3,4,248,50,//133/50mA(400A),188/50mA(100A),235/50mA(25A)  //Уставки //WAS 0xFFFF - 1*256+0x21
                                  //      0,    1,   2,  3,4, 5,6,7,8,9, 10,11
                                  //     [0]=Контр Flash
                                  //           [1]=АДР МБ
                                  //               [2]=Iмах
                                  //                   [3]=Iмin
                                  //                       [4]=Tнагр
                                  //                         [5]=0 откачка,=2 подача
                                  //                           [6]=Тзадержки ВКЛ по уровню
                                  //                             [7]=Тзадержки ОТКЛ по уровню
                                  //                               [8]= типоразмер
                                  //                                 [9]=X1 диффзащиты
                                  //                                     [10]=X2 диффзащиты
                                  //                                     [11]= уставка защиты по дифф току
      # ifdef Dt_nov
                       2,441,1,440,3,442, //441,440,442    //130ед/300A
                   // 12, 13,14,15,16,17
                   //[12]=X1 тока фазы А
                   //    [13]=X2 тока фазы A
                   //       [14]=X1 тока фазы B
                   //          [15]=X2 тока фазы B
                   //             [16]=X1 тока фазы C
                   //                [17]=X2 тока фазы C
         # else
                       2,660,1,660,3,660,
        # endif
      #ifdef TK112M
                   254,
       #else
        #ifdef ZaschTV
                   254,
       #else
                   10,
                //[18]=TimeCX задержка сброса по сух.ходу
       #endif
     #endif
                   4,5,
                //[19]=какая-то защита UstZach1
                //  [20]=какая-то защита UstZach
       //#ifndef Ppusk //WAS
                   380,   //WAS 21 //Уставка контроля Изоляции
      //#else   //WAS
      //           700,  //WAS 21 -плавный пуск
      //#endif
                  1000,  // [22]= Порог срабатыв. датчиков уровня
                     1,  //  [23]= Режимы управления Р=1(руч.реж Р),А=2,Д=3...
                     0,  //  [24]= уставка UstZach3 -> samozap
    #ifndef EnableNasos
                     0, // [25]= включить насос //UstZach2-?
   #else
                     3, // [25]= отключить насос

   #endif
                     0, 10, 700, 0, 1, 0, 50203,
              //WAS 26,27,  28,29, 30,31,32,
              //   [26]= 1, выбран Пл.Пуск,=0 выбрана Излдяция
              //      [27]=  ZD_Avar_CX - Задержка включения аварии датчика СХ
              //           [28]= 700, Уставка для Пл.Пуск
              //              [29]=рез
              //                  [30]=kol_faz(Кол.фаз, т.е.1фаза,3фазы и 2 датч.,3фаз и 2 датч)
              //                     [31]=рез
              //                       [32]=версия проекта
                     0,  2, 255,256,257,16, 33,22709 //55531
              //WAS 33, 34, 35, 36, 37, 38, 39, 40
              //   [33]= Tkz(Авар.знач. TKZ во Flash)
              //       [34]= Contr3
              //           [35]= Contr4
              //               [36]=IndArr0 - запись тока Ia при Аварии
              //                   [37]=IndArr1 - запись тока Ib при Аварии
              //                       [38]=IndArr2 - запись тока Ic при Аварии
              //                           [39]=Contr2
              //                              [40]=СRC
};
#pragma memory = default
char SL_Master; //=1 Станция является Мастером, =1 ..Плдчиненным
char KTZ; //переменная содержащая код типа защиты
          // 0 - параметры в норме
          // 1 - ассиметрия
          // 2 - перегрузка
          // 3 - сухой ход по нагрузке
          // 4 - изоляция
          // 5 - дифференциальная защита
          // 6 - cухой ход по датчику
          // 7 - неисправность датчика
          // 8 - неисправность по самодиагностике (пока не реализована)
 // Номер режима индикации после которого следуют служебные режимы индикации
#ifdef EnableNasos
#ifndef DiffZasch
 #define NumIndM 26  // если насосом управляем //18->25
#else
 #define NumIndM 26  // если насосом управляем //18->25
#endif
#else
 #define NumIndM 26 // если насосом не управляем //13->25
#endif
#define NumIndM1 26 //NumIndM_max+1(19+1) Общее кол. режимов индик.//20->25
 unsigned long Indarr_naysum_3,Indarr_naysum_4,Indarr_naysum_5,Indarr_naysum_6; //усреднение

char INDMODE; // переменная содержащая номер режима индикации
             //Список экранов дисплея ТК112
          // 1 - ГлавныйЭлектородвигатель (ЭД) включён/Выключен  On/OFF
          // 2 - *,Текущий ток фазы A     (с настройкой)
          // 3 - *,Teкущий ток фазы B    (с настройкой)
          // 4 - *,Текущий ток фазы С    (с настройкой)
          //5 - Уставка: Выбор режима работы станции Р-ручн.,А-автомат.,Д-дист
          //6 - Уставка Iн ток нагрузки (защита по току) , А
          //7 - уставка Icх - ток сухого хода (защита по току, А
          //8 - Вид работы для регулятора и Выбор датчика (оЭ/ЭКМ/Электоды/др)
          //9 - *,Уставка: Типоразмер (или выбор кольца)
          //10 -*, Уставка: постоянная времени для защиты по току (Iн и Icх), с.
          //11 -*, Уставка:фазность
          //12 -*, Уставка:Сопротивление изоляции или то же при Плавном Пуске
          //13 -*, Уставка:Самозапуск
          //14 - Асимметрия,%
          //15 - Rизол. - сопротивление изоляции, биты
          //16 -Rcx, кОм - сопротивление датчика сухого уровня, биты
          //17 -Rву, кОм - сопротивление датчика верхнего уровня, биты
          //18 -Rну, кОм - сопротивление датчика нижнего уровня, биты
          //19 -*, Уставка:Порог срабатыв. датчиков уровня
          //20 -Уставка:Тзадержки ВКЛ по уровню
          //21 - Уставка:Тзадержки ОТКЛ по уровню
          //22 - Уставка:Кол.запуск. за 4 мин
          //23 -*, Уставка:TimeCX задержка сброса по сух.ходу
          //24 -*, Уставка: Адрес МБ
          //25- Параметр: Время работы двигателя в час

          //??? 17 Уставка:задержка перед пуском насоса в регулировании по уровню,c( 50*200(Period)=10000 ms=10s)
char INDMODE_old=0;//для перекл. тек. экрана в 0

char TaskMB = 2; //1 - Start от МБ, =2 - Stop,
char Pusk_On=0;  //=1 - Start,=0- Stop, от кн.Start в режиме РУЧНОЙ
char TaskKTZ = 0;
char CounterKTZ = 0;
char StateMB =1; //1 - Stop, 2 - Start
char Comd_Driv_d;//подмена команды Command_Driv=1для реж ДИСТ-АВТ
unsigned int TimeCode105=0,TimeCode106=0,TimeCode110=0; //Счетчики ответов станции для Модема
char CommonStatus;    // Байт содержащий, служебные биты программы
                      // бит 0 - индикатор определения состояния двигателя по току
                      //         1 - двигатель включён;;
                      //         0 - двигатель выключен;
                      //  бит 1 - флаг отсчета таймером A 1 ms
                      //      0 - нет пока 1 ms (сбрасывается в прерывании  АЦП)
                      //      1 - есть 1 ms (устанавливается в обработчике прерывания таймера A)
                      //  бит 2 - сигнал запуска двигателя по кнопке Пуск
                      //           при KTZ=0 и выполнении условий пуска алгоритма насос
                      //      0 - двигатель не запускаем
                      //      1 - двигатель запускаем
                      //  бит 3 - Разрешения запрещения работы алгоритма "Насос"
                      //      0 - алгортим "Насос" выключен (сбрасывается при нажатии кнопки Стоп )
                      //      1 - алгоритм "Насос" работает (устанавливается при нажатии кнопки Пуск )
                      //  бит 4 - команда сброса по интерфейсу
                      //          1 - сделать сброс; 0 - не делать сброс
                      //        По этой команде запрещаются прерывания таймера A, что приводит к срабатыванию WDT
                      // бит 5 - флаг обновления вывода значений уставок на индикатор при изменении их
                      // по внешнему интерфейсу
                      //   0 - не обновляем значение уставки, 1 - обновляем значение уставки
                      // бит 6 - вспомогательный бит для перехода в сервисные режимы индикации
                      // бит 7 - вспомогательный бит индицирует вход в прерывание АЦП

 char LevelStatus ;   // Переменная содержащая вычесленное состояние датчиков уровня (инфо на индикатор)
                      // для индикатора и интерфейса
                      // 0 - норма (на индикаторе символ "-")
                      // 1 - уровень верхний  (на индикаторе символ "H")
                      // 2 - уровень нижний   (на индикаторе символ "L")
                      // 3 - уровень аварийный (на индикаторе символ "A")
char LevelStatusNew;  // Переменная с измеренными значениями уровня
char LevelStatus_;    // Переменная с вычисленными значениями уровня
                           // 0 бит - состояние нижнего уровня (1- контакт замкнут; 0- разомкнут)
                           // 1 бит - состояние верхнего уровня
                           // 2 бит - состояние аварийного уровня

 unsigned int *pword1;     // указатели на слова
 unsigned int *pword2;
 char cntT0,cntTM,cntTL,TKA,Tiporazmer;
 char TKA_MB;//режим работы текущий станции,передаваемый на запросы МБ
 char TaskMB_RAD;//Задание станции текущее,передаваемый на запросы МБ
 char Err_MB;      //Ошибка в МБ при посылке запросов 18 11 2019
 char Exc_code_MB; //Код Ошибки в МБ при посылке ответов при наличии Err_MB 18 11 2019
 char cntTA1,cntTA2,TimeStart;  // Счетчик интервалов в 1 ms . Инкременртируется
                                       //в обработчике прерываня Таймера А
 char cntTA3; //cчетчик 3 таймера А,обслуживающего задержками прием ModBus (RX)
 char cntTA4;//счетчик прерываний в ADС12 для усредненя замеров аналог. параметров
 char TimePuskStop,TimeCXNasos,TimeCXN;       // Таймер пуска или останова.
 //WAS
 //char g3,ww1;
 char  Samo_zp;//Повторитель самозапуска в ОЗУ
 unsigned int cnt_sbr_scrn; //Счетчик сброса n-го экрана в 0-й
 //char  Ind_faz=0;
 char  Rej_Pod=0, Rj_VU_P=0 /*подчин.режим ВУ*/,Rj_VU_N=0 /*неиспольз.режим ВУ*/;
 //WAS_10_1  для контр.перемещ. указат.стека
  //unsigned int SP1,dSP_p=0;
  //int dSP;
 //WAS_10_2  для контр.перемещ. указат.стека
 unsigned int TimeStopNasos;//,TimeStopN;// Инкременртируется в конце глобального цикла каждые 200 ms

 //WAS и Прием от/в модема   нач.
 char K5;// (K5 & 0x01) - разрешение прерывания по приему Modbus
 char NU,VU,SU; //Уровни для ответа по МБ        //WD
 char St_Driv; //Состояние мотора                //WD
char VU_NU_SX; //Битовые коды уровней для ответа //WD
 char i,i1,i2,i3,i4,i5,i6,i7,K2;
 char l2,l6,l7,Test1;
 char Kz11; //Вписывание данных приема
 char Kb5,Ks2_1,Ks2_2,Ks3_1;
 char Ks1_1; //WAS переменная определяет команды и режимы, задаваемые с модема
 char Ks1_2; //WAS переменная определяет дополнительные условия задаваемые с модема
 unsigned int i10=0; //Cчетчик циклов отсутствия ответов Подчтненного по МБ
 char SBUFrx0=0;   //Повторитель SBUFrx[0] для SL_Master
 char Temp_w; //задано тек.знач.целев.параметра в Sbufrx[6],Sbuftx[8]
 char Ppusk1; //Выбор Плавного Пуска, =1 выбран Пл.пуск,=0 не выбран,
                         //но выбрано изммерение Изоляции
 char IndArray6;
 #define ColPdByt1       11// Количество передаваемых байт /вместе с контрольной суммой/ master
char ADR1;             //ADR1-адрес подчиненного;
char ADR_SMI2=0x10;    //Адрес индикатора СМИ2;
char Quer_MB=1;
unsigned int Temp2;// Временная переменная применяется в различных местах программы
char ww=0; //WAS_ для инициализации массива arr
//char Hold_Reg[4];       //Массив для выдачи данных Мастеру db
//unsigned int Hold_Reg[10]; //25 06 2018
char SBUFfl[4];         //Массив принятыхи данных от Мастера
char SBUFtx [35]={0};   /*transmit buffer for UART */
char SBUFrx [25]={0};


   /*receive buffer for UART */
/******************************************************************************************************************
 * **************************************************************************************************************/

//Прием от модема
char Funk_Mod;           //Принятая функция
unsigned int N_ADR_Reg;  //начальный адрес регистра
unsigned int Quant_Reg;  //Количество регистров
unsigned int Hold_Reg[10]; //25 06 2018 //с 7 до 10 18 11 2019 c переходом на МБ
unsigned int RJ_Mod=31;             //Заданный режим станции (только для ДИСТАНЦ. режима):
                         //      =31 -работа по команде диспетчера
                         //       =32 -автоматич.работа(по датч.)
                         //       =33 -работа по команде диспетчера, кнопкам Пуск и Стоп
                         //           и сигналу(кнопке) Пожар
                         //игноррируется при режиме РУЧНОЙ и АВТОМАТИЧЕСКИЙ
char Task_Station;       //Заданное задание станции (только для ДИСТАНЦ. режима):
                         //  =1 - запустить автоматич.работу станции
                         //  =0 - остановить автоматич.работу станции
                         //игноррируется при режиме РУЧНОЙ и АВТОМАТИЧЕСКИЙ


char Task_Stn_Zdn_MB;       //заданное задание станции для ответа по МБ
char TKA_zdn;                //Заданный режим,выполняемый станцией
char Command_Driv;           //Команда ВКЛ/ОТКЛ мотор.Игнорируется при
                             //режиме станции АВТОМАТИЧЕСКИЙ
char Reset_Protect1;         //Сброс защиты
char Reset_Protect2;         //Сброс ограничения сбросов защиты,счетчк=0
//WAS Прием от/в модема кон.
//Для звпрлнения ответа по функциии 106
char Ogr_Kol_Vkl;//Ограничение на кол. включений Двигат. за 4 мин
char Assim_O_Prz; //Асиметрия в %
                  //Assim_O_Prz = (Assim_O / (UstImax/2)))* 100 %
char Quer;//запрос от мастер
#ifndef DiffZasch
 unsigned int Kb3;
#endif
 unsigned int K8,K14,TimeStartNasos;//,TimeSN;// Таймер задержки пуска насоса при управлении алгоритмом насос
//unsigned int TimeContr1,TimeContr2;// Таймер задержки пуска насоса при управлении алгоритмом насос
 char PerNetCount;         // Счётчик количества периодов
 unsigned int NumSamples,cntTA0;  // Cчётчик количества измерений
 unsigned int Value,Value1,LevelUst,IsolUst,UstImaxDiap;//,UstImax;//,UstIcx;
// Переменные для эспонентциального фильтра
unsigned int PhaseMax_O, PhaseCx_O, Assim_O;        // Выходные значения фильтров по максимальному току и току сухого хода  и ассиметрии
signed int   RemPhaseMax, RemPhaseCx, RemAssim;     // Остатки вычислений  фильтров по максимальному и минимальному токам и ассиметрии

char TimeHi,TimeLow,TimeTr;     // Таймера гистерезиса для датчиков уровня
//char TimePuskStopMax;
unsigned int Isol_O,TauTEMP,TimeDry;                                 // Выходное значения фильтров по изоляции
signed int   RemIsol;                                // Остаток вычисления  фильтра по изоляции

unsigned int IndArray [8];    // Данные выодимые на индикатор после перерасчёта калибровок
                              // 0 - Ток фазы А
                              // 1 - Ток фазы В
                              // 2 - Ток фазы С
                              // 3 - Диф. ток
                              // 4 - Сопротивление изоляции (битовое представление)
                              // 5 - Сопротивление нижнего уровня (битовое представление)
                              // 6 - Сопротивление верхнего уровня (битовое представление)
                              // 7 - Сопротивление аварийного уровня (битовое представление)

char MeasureControl;          // Байт управления для обработчика прерываний АЦП
                              // 0 - измеряем только токи на 2-ух фазах
                              // 1 - измеряем токи на 2-ух фазах и диффзащиту
                              //(Устанавливается по прерыванию таймера A3,
                              // cбрасывается обработчиком прерывания АЦП)
                              // 2 - измеряем все параметры
                              //(для вычислений используем только диффзащиту,
                              // сопротивления электродов, и изоляцию)
                              // 3 - ничего не измеряем останавливаем AЦП.

 //char g5; //не используется
char g1,g2,g3;
char l1; //WD  ????
char Px,PCx,K6,K7,K9, /*K10,*/ K11,K12,K13;
char K10; //Текущее значение включений двигателя от начала отсчета интервала 4 мин.
unsigned int Kb1;//Счетчик отсчета интервала 4 мин для контроля числа включ. двиг.
char K4;  // Задержка при включении насоса
char Kz1,Kz2,Kz3,Kz4,Kz5,Kz6,Kz7,Kz8,Kz9;//,Kz10;
char Kb2; //Повторитель Самозапуска, т.е. Kb2&1 - это самзапуск
char Faz; //Фазность двигателя: =1 3-х фазный с 2-я датчиками;
          //                    =2 3-х фазный с 3-я датчиками;
          //                    =3 однофазный с 3-я датчиками;
char Kb2_1;      //Безусловне выполнение самозапуска 09 05 2018
char Cr_Tpr=0; //=1 производится корректировка Типоразмера WAS13 05 2018
char More_d,Less_d; //Флаги срабвтывания кнопок Больше и Меньше
unsigned int DiffLevel;               // Уровень диффзащиты
 // Переменные для измерения дифф. тока
#ifdef DiffZasch
 unsigned int DiffZerro,DiffZerro1;      // Вычисленный нуль дифзащиты
 unsigned int DiffMid;        // Найденное значение диф. тока
 char K1,K1_1,K2,K3;
#endif
// signed int x;
// signed long Temp2;
char Tim_KTZ_6=0; //Промежуточная переменная для задержки формирования аварии по датчику СХ
unsigned long Diffsum; // Интегральная суммы значений измерений АЦП для дифференциального тока //WAS_6 восстановлено
//unsigned int DiffCurrent; // Значение дифференциального тока в битах
 unsigned int Temp; //WAS // Временная переменная применяется в различных местах программы
 //char Tempp;               // Временная переменная применяется в обработчике прерываний по АЦП
char Point4; //Положение запятой в параметре измеренного тока
  //Константы перевода десятичных цифр в их изображении "портрет" для индикатора СМИ2
                         //      0     1   2    3    4    5    6    7    8    9  . -
const unsigned char portr[12]={0xFC,0x60,0xDA,0xF2,0x66,0xB6,0xBE,0xE0,0xFE,0xF6,1,2};


unsigned int CRC_16(unsigned char *Buffer,unsigned int length);

/* Значение пароля для проверки прав доступа к корректировке заводских уставок
 * в дистанционном режиме */
#define SET_ACCESS_PASSWORD 0x1234
/* Флаг предоставления права доступа.
 * Выставляется при введении пароля дистанциооно через Модбас
 * сбрасывается - по времени или после введения сообщения сброса пароля. Обсудить.
 * */
uint8_t SetAccessFlag=0;

/* Функция обработки сообщений Модбас, полученых от Мастера
 * На вход функции поступают лишь сообщения SBUFrx, в случае
   = если СRC проверен, и целосность сообщения подтверждена
   = если адрес сообщения совпадает с адресом сообщения нашего устройства
   Размер входящего сообщения не контролируется.
   Функция выполняет все действия, предписанные входящим сообщением
   и готовит выходное сообщение SBUFtx
   =содержание запрашиваемых регистров Модбас =Response= или
   =сообщение об успешном выполнении сообщения Модбас =Response= или
   =сообщение об ошибке в структуре сообщения =Error=
   размер входного сообщения - i2, если размер нулевой,
   передача ответа не предполагается
   ***
   Обрабатываются стандартные функции Модбас 0х03, 0х06, 0х16,
   и функции корпоративного стандарта Модбас 110 и 106
   */
void fTK2_Slave3_1(void){
        Funk_Mod=SBUFrx[1]; //Принятая функция
        SBUFtx[0]=SBUFrx[0];
        uint8_t ExFlag=0;
        /****************************************************************/
        /****************************************************************/
        /* */
        if(Funk_Mod==0x03){
            N_ADR_Reg=(SBUFrx[2]<<8)+SBUFrx[3];  //начальный адрес регистров
            Quant_Reg=(SBUFrx[4]<<8)+SBUFrx[5];  //Количество регистров
            if((N_ADR_Reg>=0x0100)&&(N_ADR_Reg<0x0110)){
            	if ((N_ADR_Reg+Quant_Reg)>0x0110){
				/* Некорректный начальный адрес или количество регистров
				 * при чтении параметров */
            		SBUFtx[1]=Funk_Mod+0x80; /* Error code */
            		SBUFtx[2]=0x02;/* Exception code код ошибки по стандарту Модбас */
            		i2=3;
            	}
            	else{
            	/* подготовка ответа при корректном задании начального адреса и количества регистров
            	 * при чтении параметров работы єлектродвигателя */
            		SBUFtx[1]=Funk_Mod;
            		SBUFtx[2]=(uint8_t)(Quant_Reg*2);
            		uint16_t M[16]={0};
                     M[0]=(uint16_t)TKA_MB; //режим текущий
                     M[1]=(uint16_t)TaskMB_RAD; //задание текущее
                     M[2]=(uint16_t)St_Driv;  //Cостояние мотора
                     M[3]=(uint16_t)KTZ;      //Защита (наличие аварии)
                     M[4]=(uint16_t)VU_NU_SX; //Битовые коды уровней
                     M[5]=IndArray[0]; //I1
                     M[6]=IndArray[1]; //I2
                     M[7]=IndArray[2]; //I3
                     M[8]=Isol_O;      //    Измеренное сопротивление изоляции
                     M[9]=Assim_O_Prz; //         Измеренная асимметрия в %
                     M[10]=IndArray [7]; //         Измеренный  уровень CХ
                     M[11]=IndArray [5]; // Измеренный  нижний уровень НУ
                     M[12]=IndArray [6]; // Измеренный  верхний уровень ВУ
                     M[13]=arr[ver_prj]; //версия проекта
                     M[14]=TimeCode105;  //счетчик обменов

            		SBUFtx[1]=Funk_Mod;
            		SBUFtx[2]=(uint8_t)(Quant_Reg*2);
            		for(uint8_t i=0;i<Quant_Reg;i++){
            			SBUFtx[3+2*i]=  M[i]/0x100;
            			SBUFtx[3+2*i+1]=M[i]%0x100;
            		}
            		i2=SBUFtx[2]+3;
            	}
            }
            /* чтение первой группы уставок, пользовательстких  */
            else if((N_ADR_Reg>=0x1000)&&(N_ADR_Reg<=0x1008)){
            	if(N_ADR_Reg+Quant_Reg<=0x1008){
            			SBUFtx[1]=Funk_Mod;
            			SBUFtx[2]=(uint8_t)(Quant_Reg*2);
            			for(uint8_t i=0;i<Quant_Reg;i++){
            				SBUFtx[3+2*i]=  arr[N_ADR_Reg-0x1000+i] / 0x100;
            				SBUFtx[3+2*i+1]=arr[N_ADR_Reg-0x1000+i] % 0x100;
            			}
            			i2=SBUFtx[2]+3;
                }
            	else{ExFlag=0x02;}

            }
            /* чтение второй группы уставок - заводских         */
            else if((N_ADR_Reg>=0x01014)&&(N_ADR_Reg<=0x0101F)){
            	if(N_ADR_Reg+Quant_Reg<=0x101F){
            		SBUFtx[1]=Funk_Mod;
            		SBUFtx[2]=(uint8_t)(Quant_Reg*2);
            		for(uint8_t i=0;i<Quant_Reg;i++){
            			SBUFtx[3+2*i]=  arr[N_ADR_Reg-0x1014+i] / 0x100;
            			SBUFtx[3+2*i+1]=arr[N_ADR_Reg-0x1014+i] % 0x100;
            		}
            		i2=SBUFtx[2]+3;
            	}
            	else{ExFlag=0x02;}
            }
            else{
				/* Некорректный начальный адрес или количество регистров
				 * при чтении параметров */
            	ExFlag=0x02;
            }
        }/* конец работи по функции 0х03 = читать группу регистров
            начало работы по функции 0х06 = писать один регистр  */
        else if ((Funk_Mod==0x06)){
        	N_ADR_Reg=(SBUFrx[2]<<8)+SBUFrx[3];
        	uint16_t RegValue=(SBUFrx[4]<<8)+SBUFrx[5];
        	if(N_ADR_Reg==0x0000){
        		if((RJ_Mod==31)||(RJ_Mod==32)||(RJ_Mod==33)){
        			//Команда: Заданный режим работы станции
        			if((RegValue==31)||(RegValue==32)||(RegValue==33)){
        				RJ_Mod=RegValue;
        			}
        			/* Недопустима операція для поточного режиму роботи */
        			else{ExFlag=0x55;}
        		}
        		/* Недопустиме значення режиму роботи */
        		else {ExFlag=0x56;}
        	}
        	else if(N_ADR_Reg==0x0001){
        		//Задание на автоматич.работу станции
        		if((RegValue==0)||(RegValue==1)){
        			if(RJ_Mod==32){
        			/* воспринимается только в режиме дист.автоматический */
        				Task_Station=RegValue;
        			}
        			else{
        				//игноррируется при режиме РУЧНОЙ
        				ExFlag=0x56;/*недопустиме завдання для заданого режиму роботи */
        			}
        		}
        		else{
        			ExFlag=0x57;/*недопустимий режим роботи */
        		}
        	}
        	else if(N_ADR_Reg==0x0002){
        			if(RJ_Mod==32){
        				ExFlag=0x58;/* Недопустима команда при дист.автоматичесному режимі */
        			}
        			else if ((RJ_Mod==31)||(RJ_Mod==33)){
        				Command_Driv=RegValue;//Команда ВКЛ/ОТКЛ мотор.
        				//Формирование флага-подмены команды Command_Driv=1для реж ДИСТ-АВТ
        				// Тут я ничего не понимаю, В.Д., вам здесь нужно все проверить - переделать так как у вас біло
        				if((TKA==4)&&(Task_Station==1)&&(Command_Driv==1)&&(NU)){Comd_Driv_d=1;}
        				if((TKA==3)||(TKA==4)||(TKA==5)){
        				    	//Имеется команда на вкл./откл. двигателя нереверсивного привода-?
        				        //Выполнена перекодировка команд 1->
        				        if((Command_Driv==1)||(Command_Driv==10)) {TaskMB =1;} //ДА, Вкл. двигатель нереверсивного ...
        				        //ДА, Вкл. вперед двигатель задвижки
        				        else if(Command_Driv==11) {TaskMB =2;} //ДА,Откл. двигатель
        				        //ДА, Вкл. назад двигатель задвижки 18 06 2018
        				        else if(Command_Driv==2) {TaskMB =3;} //Да,Отключить двигатель задвижки   18 06 2018
        				        else{ExFlag=0x59;}/* недопустимая команда на включение/отключение ЭД */
        				}
        				else{
        					ExFlag=0x59;/* какая-то ошибка, не знаю какая Что такое ТКА? */
        				}
        			}
        			else{
        				ExFlag=0x58;/* Недопустима команда при дист.автоматичесному режимі */
        			}
        	}
        	else if(N_ADR_Reg==0x0003){
        		Reset_Protect1=RegValue;	 //Сброс защиты ???????????????????
        	}
        	else if(N_ADR_Reg==0x0004){
        		Reset_Protect2=RegValue;	 //Сброс защиты ???????????????????
        	}
        	else if(N_ADR_Reg==0x0005){
        		if(RegValue==SET_ACCESS_PASSWORD){
        			SetAccessFlag=0x0001;	 //Сброс защиты ???????????????????
        			/* По уму, тут нужно запустить таймер, и через заданное время
        			 * сбросить флаг введенного пароля SetAccessFlag=0x0000;*/
        		}
        		else{
        			ExFlag=0x60;/* Неправильний пароль */
        		}
        	}
        	else if(N_ADR_Reg==0x0006){
        		/* Что угодно вводится в ячейку 6 - сбрасывается флаг введенного пароля */
        		SetAccessFlag=0x0000;
        	}
        	/* КОНЕЦ ЗПИСЕЙ РЕГИСТРОВ КОМАНД
        	нАЧАЛО ЗАПИСЕЙ РЕГИСТРОВ УСТАВОК */
        	/*******************************************************************/
        	else if((N_ADR_Reg>=0x1000)&&(N_ADR_Reg<=0x1008)){
        		uint16_t arri=N_ADR_Reg-0x1000;
        		arr[arri]=RegValue;
        	}
        	else if((N_ADR_Reg>=0x1020)&&(N_ADR_Reg<=0x1030)){
        		if(SetAccessFlag==0x0001){
        			arr[N_ADR_Reg-0x1000]=RegValue;
        		}
        		else{
        			ExFlag=0x60;/* Відмова у доступі */
        		}
        	}

        	else{
        		ExFlag=0x02;
        	}
        	/* Формирование положительного ответа по команде 0х06
        	 * если не было обнаружено ошибки */
        	if(ExFlag==0x00){
        		SBUFtx[1]=Funk_Mod; /* Код команди Модбас                       */
        		SBUFtx[2]=SBUFrx[2];/* Адрес регистра для записи, старший байт  */
        		SBUFtx[3]=SBUFrx[3];/* Адрес регистров для записи, младший байт */
        		SBUFtx[4]=SBUFrx[4];/* Значение регистра для записи старший байт*/
        		SBUFtx[5]=SBUFrx[5];/* Значение регистра для записи младший байт*/
        		i2=6;               /* количество байт без CRC */
        	}
        }

        /* Конец работы с командой 0х06
         * Начало работы с командой 0х10 */
        else if ((Funk_Mod==0x10)){
        	N_ADR_Reg=(SBUFrx[2]<<8)+SBUFrx[3];  //начальный адрес регистров
        	Quant_Reg=(SBUFrx[4]<<8)+SBUFrx[5];  //Количество регистров
        	uint8_t N_bytes=SBUFrx[6];
        	if((Quant_Reg<0x0001)||(Quant_Reg>0x007B)
				&&(N_bytes!=(uint8_t)(Quant_Reg*2))){
        		ExFlag=0x03;
        	}
        	else{
        		uint16_t RegValue16=0;
				/* Груповая запись настроек пользователя */
        		if((N_ADR_Reg==0x01000)&&(Quant_Reg==8)){
        			for(uint8_t i=0;i<Quant_Reg;i++){
        				RegValue16=(SBUFrx[7+2*i]<<8)+SBUFrx[7+2*i+1];
        				arr[N_ADR_Reg-0x1000+i]=RegValue16;
        			}
        		}
        		/* Груповая запись настроек заводских */
        		else if((N_ADR_Reg==0x01000+20)&&(Quant_Reg==11)){
        			/* Пароль верен */
        			if(SetAccessFlag==0x0001){
        				for(uint8_t i=0;i<Quant_Reg;i++){
        					RegValue16=(SBUFrx[7+2*i]<<8)+SBUFrx[7+2*i+1];
        					arr[N_ADR_Reg-0x1000+20+i]=RegValue16;
        				}
        			}
        			/* Пароль не введен или не верен */
        			else{
        				ExFlag=0x60;/* Відмова у доступі */
        			}
        		}
        		else{ExFlag=0x02;}
        	}
        	/* Формирование положительного ответа по команде 0х10
        	 * если не было обнаружено ошибки */
        	if(ExFlag==0x00){
        		SBUFtx[1]=Funk_Mod; /* Код команди Модбас                       */
        		SBUFtx[2]=SBUFrx[2];/* Адрес регистров для записи, старший байт  */
        		SBUFtx[3]=SBUFrx[3];/* Адрес регистров для записи, младший байт */
        		SBUFtx[4]=SBUFrx[4];/* Количество регистров, старший байт*/
        		SBUFtx[5]=SBUFrx[5];/* Количество регистров, младший байт*/
        		i2=6;               /* количество байт в исходящем сообщ. без CRC */
        	}
        }
        /* Конец обработки команды 0х10 */
        else if(Funk_Mod==106){
          SBUFtx[1]=Funk_Mod;  //Функция
          SBUFtx[2]=arr[PowerMotor]; //Типоразмер TimeCX
          SBUFtx[3]=arr[DeleyStartN]; //Задержка включения даигателя
          SBUFtx[4]=arr[DeleyStopN]; //Задержка отключения даигателя
          SBUFtx[5]=arr[PodOtkSelSens]; //Подача/Откачка, тип Датч.
          SBUFtx[6]=arr[samozap];    //Самозапуск
          SBUFtx[7]=arr[TimeCX];    //ремя восстановления после срабатывания по СХ
          SBUFtx[8]=arr[kol_zap]; //Ограничение на кол. включений Двигат. за 4 мин
          Hold_Reg[0]=arr[Imax1kVt]; //Защита двигателя по Imax
          Hold_Reg[1]=arr[Icx1kVt];  //Защита двигателя по Imin сухого хода ???   LevelUst1
          Hold_Reg[2]=arr[LevelUst1];  //Порог срабатывания электродного датчика
          Hold_Reg[3]=arr[IsolUst1];   //Настройка на срабатывание изоляции или плавного пуска
          Hold_Reg[4]=arr[TauI];   //Настройка Т нагрева
          Hold_Reg[5]=arr[ver_prj]; //версия проекта
          Hold_Reg[6]=TimeCode106; //счетчик обменов
           //Выполнить перестановку местами байтов для Hold_Reg
            // и записать их в SBUFtx, начиная SBUFtx[10], т.е.
          i2=9;i3=7;
          for(i4=0;i4<i3;i4++)
           {Temp2=Hold_Reg[i4];SBUFtx[i2]=Temp2/256;//старший байт затем младший
           SBUFtx[i2+1]=Temp2%256;i2=i2+2;}
        }
          //==//==//==//==//==Подготовка ответа по функции 106 ==//==//==//==//кон

           //==//==//==//==//==Подготовка ответа по функции 110 ==//==//==//==//нач
        else if(Funk_Mod==110){
         SBUFtx[1]=Funk_Mod;  //Функция
         //Имеются след. режимы работы:
         //РУЧНОЙ =1,на индикаторе ТК цифра 1, TKA=1
         //АВТОМАТ =2,на индикаторе ТК цифра 2, TKA=2
         //ДИСТ.РУЧН.=31,на индикаторе ТК цифра 3, TKA=3
         //ДИСТ.АВТОМАТ.=32,на индикаторе ТК цифра 3, TKA=4
         //Режим текущий записан в ТКА
         SBUFtx[2]=TKA_MB;    //Режим работы текущий
         SBUFtx[3]=RJ_Mod; //Режим заданный TKA_zdn
         SBUFtx[4]=TaskMB_RAD;    //Задание текущее
         SBUFtx[5]=Task_Station; //Задание заданное
         if((TKA==5)&&(Pusk_On))SBUFtx[5]=Pusk_On;//Задание заданное
         SBUFtx[6]=St_Driv; //Состояние мотора
         SBUFtx[7]=KTZ;       //Защита (наличие аварии)
         SBUFtx[8]=CounterKTZ; //Счетчик сбросов
         Hold_Reg[0]=arr[ver_prj]; //версия проекта
         Hold_Reg[1]=TimeCode110; //счетчик обменов
         //Выполнить перестановку местами байтов от TimeCode106
         i2=9;i3=2;
         for(i4=0;i4<i3;i4++){
             Temp2=Hold_Reg[i4];SBUFtx[i2]=Temp2/256;//старший байт затем младший
             SBUFtx[i2+1]=Temp2%256;i2=i2+2;
         }
       }
       /* Конец обработки по функции 110
        * Конец обработки по всем реализованім функциям */

      else{
      /* Если это команда, которая у нас не реализована
       * формируем сообщение об ошибке 0х01                           */
    	ExFlag=0x01;
      }

      /* Все команды, кроме команды 110 предполагают ответ подчиненной станции,
       * ответ = или содержание запрашиваемых регистров,
                 или квитанция о выполнении записи в регистры
                 или сообщение об ошибке
        Вынесенная за скобки подготовка исходящего сообщения в случае обнаруженной ранее ошибки */
      if(ExFlag){
        	SBUFtx[1]=Funk_Mod+0x80; /* Error code */
        	SBUFtx[2]=ExFlag;/* Exception code код ошибки по стандарту Модбас */
        	i2=3;
      }
      if(i2>0){/* если i2==0, ответ не передается, как при команде 106 */
        Temp2=CRC_16((unsigned char*)&SBUFtx[0],i2);        //KC контрольная сумма
        SBUFtx[i2]=  Temp2 % 256;
        SBUFtx[i2+1]=Temp2 / 256;
        i2=i2+2;//младший байт KC затем старший
      }
      /* То же самое - выход функции, передачу ответа подчиненного устройства
       * нужно делать лишь тогда, когда і2>9  */
}


//Подсчет контрольной суммы
 unsigned int CRC_16(unsigned char *Buffer,unsigned int length)//length
  {unsigned int i,j,bit,Temp,CRC;
  CRC=0xFFFF;
  for(i=0;i<length;i++)
  {Temp=(unsigned char)*Buffer++;
    CRC^=Temp;
    for (j=0;j<8;j++)
   {bit=CRC&0x0001;CRC>>=1;
   if(bit)CRC^=0xA001;}}
  //WAS_нач
  //  asm ( "mov SP,&SP1");
  //  dSP=1023-SP1 ;
  //  if(dSP>dSP_p)dSP_p=dSP;
  //WAS_кон
   /*K7=CRC;*/return(CRC);}
