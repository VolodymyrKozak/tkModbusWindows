///*
// * tk2_mb_queue.c
// *
// *  Created on: 29 груд. 2019 р.
// *      Author: KozakVF
// */


//#include "stdafx.h"
//#include <iostream>

#include "vk_wqueue.h"

#define VKQUEUE
#ifdef VKQUEUE


/*
Каждый узел однонаправленного (односвязного) линейного списка (ОЛС) содержит одно поле указателя
на следующий узел. Поле указателя последнего узла содержит нулевое значение (указывает на NULL).
Односвязный линейный список
По содержимому узел списка можно обратиться к следующиму элементу, но нельзя обратиться к предыдущему.
Голова списка - узел, адрес которого нужно знать, чтобы не потерять список.
Хвост - узел, который не указывает ни на один другой узел.
*/
/*
Инициализация обработчика очереди списка
Инициализация списка, если пустой
Добавление узла в хвост списка
Добавление узла в голову списка
По мере использования - уничтожение узлов в голове списка

*/
static void * init(
		void* p,     /* ссылка на тело первого элемента списка для перезаписи его в очередь*/
		size_t size, /* размер элемента списка */
		queue_t *pq  /* ссылка на обработчик очереди */
		);           /* передача в вызывающую программу ссылки на голову списка */





/* Добавление узла в хвост очереди */
int addtail(
		void *p,   /* Ссылка на тело элемента в вызывающей программе
					  для перезаписи его в очередь */
		size_t size,/*Размер тела элемента списка */
		queue_t *pq /*Ссылка на обработчик очереди */
		){
	if((p==NULL)||(pq==NULL)){return -1;}
	if(pq->first==NULL){
		/* Якщо черга пуста - заповнюємо її першим елементом */
		pq->first= init(
				p,     /* ссылка на тело первого элемента списка для перезаписи его в очередь*/
				size, /* размер элемента списка */
				pq  /* ссылка на обработчик очереди */
				); // а- значение первого узла
	}
	else{
	// выделение памяти под хвост списка
		  void *p_in = malloc(size+8);
		  /* перепись области памяти, где хранилось нечто, что ставится в очередь
		   * в тело списка в очереди   */
		  memcpy(p_in, p, size);
		  /* фиксация 32 бит для записи ссылки на следующий элемент списка */
		  void *vp    = p_in+size;
		  uint32_t *pp=(uint32_t*)vp;
		  uint32_t *ppp=NULL;
		  /* Запись нуля, это ведь хвост, как ссылки на следующий элемент*/
		  (*pp) = (uint32_t)ppp;
	  /* Поиск текущего хвоста */
	  /*  Ссылка в голове на следующий узел*/
	  /* Cсылка на голову */
//	  void* next = inhead;
//	  do{
//		  /* адрес на ссылку на следующий узел*/
//	  	  void *adrnext = next+size;
//	  	  uint32_t *adr32next = (uint32_t*)adrnext;
//	  	  /* Вытаскиваем в интеджер ссылку из этго адреса */
//	  	  uint32_t next32=(*adr32next);
//	  	  uint32_t *pnext32 = (uint32_t*)next32;
//	  	  /*вот она в итоге*/
		  /* Но єто все не нужно, у нас есть адрес старого хвоста */
		  /* Вычисляем адрес ссылки на следующий узел */
		  void* addr = pq->last +size;
		  /* ссылку преобразуем в 32-розрядную*/
		  uint32_t *app=(uint32_t*)addr;
		  /* Адрес нового хвоста ищем как число */
		  uint32_t *ip_in=(uint32_t*)p_in;
		  uint32_t ippp=(uint32_t)ip_in;
		  /* Записиваем по этому адресу ссылку на новый хвост */
		  (*app) = (uint32_t)ippp;
	  /* Ведение обработчика очереди */
	  /* Голову не трогаем, голова осталась на месте */
	  pq->last=p_in;
	  pq->node_number++;
	  /* Возвращение длині очереди */
	}
	return pq->node_number;
}
/* Добавление элемента в голову очереди */
void * addhead(
		void *p,	/* Ссылка на тело элемента в вызывающей программе
					  для перезаписи его в очередь */
		size_t size,/*Размер тела элемента списка */
		queue_t *pq /*Ссылка на обработчик очереди */
		){
	if(pq->first==NULL){
		/* Якщо черга пуста - заповнюємо її першим елементом */
		pq->first= init(
				p,     /* ссылка на тело первого элемента списка для перезаписи его в очередь*/
				size, /* размер элемента списка */
				pq  /* ссылка на обработчик очереди */
				); // а- значение первого узла
	}
	else{
	  // Выделение памяти под новую голову списка
	  void *p_in = malloc(size+8);
	  /* перепись области памяти, где хранилось нечто, что ставится в очередь
	   * в тело списка в очереди   */
	  memcpy(p_in, p, size);
	  /* фиксация 32 бит для записи ссылки на следующий элемент списка */
	  void *pv    = p_in+size;
   	  uint32_t *pp=(uint32_t*)pv;

	  /* Запись ссылки в новою голову на теперешнюю голову,
	   * которая подвигается на единицу в сторону хвоста */
   	  void *np = pq->first;
	  uint32_t *ppp=(uint32_t *)np;
	  (*pp) = (uint32_t)ppp;

	  /* Ведение обработчика очереди */
	  pq->first=p_in;
	  pq->node_number++;
	  /* Возвращение новой ссілки на голову списка  */
	}
	return pq->first;
}
/*
Возвращаемым значением функции является адрес добавленного узла.

/* Удаление головы */
void * deletehead(
		size_t size,/* размер головы */
		queue_t *pq /* Ссылка на обработчик очереди */
		){
	/* Если в списке 0 элементов, то удалять нечего */
	if(pq->node_number==0){return NULL;}
	/* Вытаскиваем с головы ссылку на следующий элемент */
	/* aдреса де показчик зберігається */
	void *pp = pq->first+size;
	uint32_t *p32=(uint32_t*)(pp);
	/* власне читаємо за цією адресою показчик*/
	uint32_t iptr = (uint32_t)(*p32);
	uint32_t* ptr32= (uint32_t*)iptr;
	void *ptr  = NULL;
	ptr=(void*)ptr32;
	/* Убиваем голову */
	free(pq->first);
	pq->first=NULL;
	/* Ведем обработчик очереди */
	pq->node_number--;
	pq->first=ptr;
	/* С хвосом ничего не поменялось, не трогаем но
	 * если  удалили единственный элемент,
	 * хвоста у нас нет тоже */
	if(pq->node_number==0){
		pq->last=ptr;
	}
	/* Возвращаем ссылку на новую голову*/
	return ptr;
}

static void * init(
		void* p,     /* ссылка на тело первого элемента списка для перезаписи его в очередь*/
		size_t size, /* размер элемента списка */
		queue_t *pq  /* ссылка на обработчик очереди */
		){ // а- значение первого узла
  // выделение памяти под корень списка
  void *p_in = malloc(size+8);
  /* перепись области памяти, где хранилось нечто, что ставится в очередь
   * в тело списка в очереди   */
  memcpy(p_in, p, size);
  /* фиксация 32 бит для записи ссылки на следующий элемент списка */
  void *pr = p_in+size;
  uint32_t *pp=(uint32_t*)pr;
  uint32_t *ppp=NULL;
  /* Запись нуля, это ведь и корень и хвост, как ссылки на следующий элемент*/
  (*pp) = (uint32_t)ppp;
  /* Ведение обработчика очереди */
  pq->first=p_in;
  pq->last=p_in;
  pq->node_number=1;
  /* передача в вызывающую программу ссылки на голову списка */
  return(p_in);
}




void test_queue(void){
	// 1) Створити структуру опису черги
	queue_t QueueTest = {0};
	/* Перший елемент - в чергу, цей елемент стає
	 * і головою і хвостом списку одночасно.
	 * Наприклад, елемент це - слово:
	 * */
	uint32_t w[10]={0,1,2,3,4,5,6,7,8,9};


	void *hEad = NULL;
	volatile uint8_t N=0;
	if(QueueTest.node_number==0){
		uint32_t* p32 = &(w[1]);

	hEad = init(
			(void*)&(w[1]),
			sizeof(uint32_t),
			&QueueTest
			);
	}
	hEad=addhead(
			(void*)(&w[9]),
			sizeof(uint32_t),
			&QueueTest
			);
	hEad =deletehead(

			sizeof(uint32_t),/* размер головы */
			&QueueTest /* Ссылка на обработчик очереди */
			);//Возвращаемым значением функции является ccлка на новую голову
	N= addtail(

			(void*)(&w[2]),
			sizeof(uint32_t),
			&QueueTest
			);
	N= addtail(

			(void*)(&w[3]),
			sizeof(uint32_t),
			&QueueTest
			);
	hEad =deletehead(

			sizeof(uint32_t),/* размер головы */
			&QueueTest /* Ссылка на обработчик очереди */
			);//Возвращаемым значением функции является ccлка на новую голову
	hEad =deletehead(

			sizeof(uint32_t),/* размер головы */
			&QueueTest /* Ссылка на обработчик очереди */
			);//Возвращаемым значением функции является ccлка на новую голову
	/* Вытащить тело головы списка: */

			uint32_t *p32head = NULL;
			p32head=(uint32_t*)hEad;
			uint32_t value32=(*p32head);

}


#endif
